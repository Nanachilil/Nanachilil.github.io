{"posts":[{"title":"设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点 -001","text":"设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点 总结​ 由于L为引用，是直接对原链表进行操作，所以不会断链。 ​ 参数引用是L-&gt;next,自我调用函数执行完后，虽然p所指结点被删除了，但是返回的依然是L-&gt;next。返回后，整个表是连续的。外层函数并不知道，内层调用时，L移动了位置。 代码123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;void Del_X_3(LinkList &amp;L,ElemType x){ LNode *p; //p指向待删除结点 if(L==NULL) return; if(L-&gt;data==x){ p=L; L=L-&gt;next; delete p; Del_X_3(L,x); } else //若L所指结点值不为x Del_X_3(L-&gt;next,x);}","link":"/posts/f8ef9f43/"},{"title":"带头结点的单链表L，删除所有值为x的结点，并释放空间，假设x唯一 -002","text":"带头结点的单链表L，删除所有值为x的结点，并释放空间，假设x唯一 总结删除结点时，使用first，second两个指针来遍历删除 代码1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;LinkList Del_X(LinkList &amp;L,int x){ LNode *first,*second; //first，second两个指针一前一后，遍历整个链表，并实现删除时连接 second=L; first=L-&gt;next; while(first!=NULL){ if(first-&gt;data==x){ second-&gt;next=first-&gt;next; delete first; first=second-&gt;next; }else{ first=first-&gt;next; second=second-&gt;next; } } return L;}","link":"/posts/68c06b74/"},{"title":"带头结点代码，单链表逆置，辅助空间为O(1) -005","text":"带头结点代码，单链表逆置，辅助空间为O(1) 总结将头结点和之后结点断开，头插法插入。断开后，无头结点的链表，需要p，r两个指针（p为工作指针，r=p-&gt;next防止断链） 代码1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;LinkList Reverse_l(LinkList &amp;L){ LNode *p,*r; //p为工作指针，r作为后继指针防止断链 p=L-&gt;next; L-&gt;next=NULL; while(p!=NULL){ r=p-&gt;next; p-&gt;next=L-&gt;next; L-&gt;next=p; p=r; } return L;}","link":"/posts/b6fb7676/"},{"title":"带头结点的单链表L，删除一个最小结点的高效算法（假设最小结点是唯一的） -004","text":"带头结点的单链表L，删除一个最小结点的高效算法（假设最小结点是唯一的） 总结​ 遍历指针，使用两个first，second（使用两个分别定位p，pre） ​ 最小值删除指针，使用两个p，pre 代码123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;void Del_min(LinkList &amp;L){ LNode *p=L-&gt;next,*pre=L; //p指向最小的结点.pre指向最小结点的前驱 LNode *first=p,*second=L; //first second 用于遍历单链表 while(p!=NULL){ if(p-&gt;data&lt;first-&gt;data){ first=p; second=pre; } second=first; first=first-&gt;next; } pre-&gt;next=p-&gt;next; delete p;}","link":"/posts/c9cd15b6/"},{"title":"带头结点的单链表L，设计一个算法使其元素递增 -006","text":"带头结点的单链表L，设计一个算法使其元素递增 总结​ 先构成只含一个数据结点的有序单链表，然后以此扫描单链表中剩下的结点p（直至p==NULL为止），在有序表中通过比较查找插入P的前驱结点pre，然后将p插入到pre之后。 代码1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;void Sort(LinkList &amp;L){ LNode *p=L-&gt;next,*pre; //p，pre分别作为两个链表的工作指针 LNode *r=p-&gt;next; //r为p的后继结点，保证不断链 p-&gt;next=NULL; //构造只含有一个数据结点的有序表 p=r; //使得p作为单链表的工作指针 while(p!=NULL){ r=p-&gt;next; //将r后移防止断链 pre=L; //每次循环，保证pre指向头结点，方便从头开始比较大小 while(pre-&gt;next!=NULL&amp;&amp;pre-&gt;next-&gt;data&lt;p-&gt;data){ //比较大小，直到满足，才在pre后面插入p结点 pre=pre-&gt;next; } p-&gt;next=pre-&gt;next; //插入的通用算法 pre-&gt;next=p; p=r; }}","link":"/posts/1f97bd59/"},{"title":"设有两个栈s1、s2都采用顺序栈方式，并共享一个存储区[0,  ,maxsize-1],为了尽量利用空间，减少溢出的可能，可采用栈顶相向，迎面增长的存储方式。试设计s1、s2有关入栈和出栈的操作方式 -008","text":"设有两个栈s1、s2都采用顺序栈方式，并共享一个存储区[0, ,maxsize-1],为了尽量利用空间，减少溢出的可能，可采用栈顶相向，迎面增长的存储方式。试设计s1、s2有关入栈和出栈的操作方式 总结算法思路​ 1、共享栈的定义 ​ 2、共享栈两个指针在入栈、出栈时的操作 代码注意点​ 1、共享栈的定义：数组空间、数组存储的两个栈顶指针 ​ 2、exit(0)和return的区别，exit(0)是直接终止进程，return是返回函数调用。 ​ 3、return 0：第一个含义一般用在主函数结束时，按照程序开发的一般惯例，表示成功完成本函数。第二个含义表示假，一般用于bool函数返回值。在C++中也可以直接用int，返回值为0时为假。宏定义ERROR 与FLASE一般为0。 ​ return 1: 与return 0 的第二个含义相对应，表示真，正确。宏定义TRUE，OK一般为1。 ​ return -1: 与return 0 的第一个含义相对应，表示返回一个代数值，一般用在子函数结尾。按照程序开发的一般惯例，表示该函数失败，在数据结构中，一般指**数据溢出(栈只会出现上溢)**，宏定义OVERFLOW 一般为-1。 ​ 4、switch每一个case后面都要有break 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#define maxsize 100#define ElemType int //定义ElemType为int类型using namespace std;typedef struct{ ElemType stack[maxsize]; int top[2]; //top为两个栈顶指针}stk;stk s; //s为全局变量//入栈操作int push(int i,ElemType x){ //i为栈号，i=0表示左边的s1栈，i=2表示右边的s2栈，x为入栈元素 if(i&lt;0||i&gt;1){ cout&lt;&lt;\"输入错误\"&lt;&lt;endl; exit(0); //exit(0)终止程序 } if(s.top[1]-s.top[0]==1){ cout&lt;&lt;\"已满\"&lt;&lt;endl; return 0; } switch(i){ case 0: s.stack[++s.top[0]]=x; return 1;break; case 1: s.stack[--s.top[1]]=x; return 1;break; }}//出栈ElemType pop(int i){ //i表示栈号 if(i&lt;0||i&gt;1){ cout&lt;&lt;\"栈号错误\"&lt;&lt;endl; exit(0); } switch(i){ case 0: if(s.top[0]==-1){ cout&lt;&lt;\"栈空\"&lt;&lt;endl; return -1; }else{ return s.stack[s.top[0]--]; } break; case 1: if(s.top[1]==maxsize){ cout&lt;&lt;\"栈空\"&lt;&lt;endl; return -1; }else{ return s.stack[s.top[1]--]; break; } }//switch}","link":"/posts/8d6133f4/"},{"title":"GVim_配置分享","text":"来给大家分享一下个人使用的GVim配置，该文章后续会一直更新。我是一位初学vim的小萌新，打算用这篇文章记录下GVim的学习历程哈哈。希望也能帮到大家。如有不足，欢迎留言。🙏 自我介绍自 LazyVim 出现以后，我也尝试过 neovim 。但一段时间后，又转回了GVim。有两方面原因： LazyVim很方便，提供了大量的快捷键操作，快捷的插件管理。但是正因如此，我需要花费大量的成本去学习。现在的我确实没有足够的时间成本去学习这门工具 自己更喜欢从无到有，一步一个脚印的去掌握这门工具。从根基开始建立一栋大楼，更加有成就感。同时，这也能让我在实践中确切明白自身的需求，回归工具的本质。提高熟练度的同时，规避了臃肿的配置。 插件配置12345678910111213141516171819202122232425262728293031323334call plug#begin('~/vimfiles/plugged')Plug 'chr4/nginx.vim'Plug 'vim-scripts/c.vim'Plug 'scrooloose/nerdtree'Plug 'scrooloose/syntastic'Plug 'preservim/vim-indent-guides'Plug 'neoclide/coc.nvim', {'branch': 'release'} \"补全Plug 'vim-airline/vim-airline' \"状态栏 Plug 'vim-airline/vim-airline-themes'Plug 'scrooloose/nerdcommenter' \"注释Plug 'junegunn/vim-easy-align' \"对齐Plug 'dense-analysis/ale' \"语法检查call plug#end()\"-------------- vim 的插件设置------------------\"\" NerdTreemap &lt;F3&gt; :NERDTreeMirror&lt;CR&gt;map &lt;F3&gt; :NERDTreeToggle&lt;CR&gt;let NERDTreeShowBookmarks=1 \"当打开NERDTree窗口时，自动显示Bookmarks\" YouCompleteMe\"vim-indent\" 随 vim 自启动let g:indent_guides_enable_on_vim_startup=1\" 从第二层开始可视化显示缩进let g:indent_guides_start_level=2\" 色块宽度let g:indent_guides_guide_size=1\"---------------------------------------------------\" 界面基础设置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566\" 字体设置set guifont=Fira_Code_medium:h14:W500:cANSI:qDRAFT\" 案件映射map J 5gjmap K 5gkmap j gjmap k gkmap H ^map L $imap jk &lt;Esc&gt;nmap &lt;space&gt;&lt;Cr&gt; :nohls&lt;Cr&gt;\"代码高亮syntax on\"工具栏取消set guioptions=\"显示行号set number\"gvim的tab默认长度set tabstop=4set expandtabset shiftwidth=4\"指定文件的编码方式\"Vim 在与屏幕/键盘交互时使用的编码(取决于实际的终端的设定) \" 编码设置set encoding=utf-8set fileencodings=utf-8,cp936,gb2123if has(\"win32\") set fileencoding=utf-8else set fileencoding=utf-8endifsource $VIMRUNTIME/delmenu.vim \"解决菜单乱码source $VIMRUNTIME/menu.vimlanguage messages zh_CN.utf-8 \"解决consle输出乱码\"显示括号之间的匹配set showmatch\"支持鼠标操作set mouse=a\"自动缩进set autoindent\"set smartindent\"最后状态栏变为两行set laststatus=2\"看到每次输入的指令set showcmd\"支持256位颜色set t_Co=256\"通过退格键换行set backspace=start,eol,indent\"开启搜索代码高亮set hlsearchset incsearch\"保证最下面5行set scrolloff=5\"组合键的时间间隔set timeoutlen=500\"指定行数和列数set lines=30 columns=80\"背景颜色colorscheme darcula GUI1234567891011121314151617181920\" 标签页 set showtabline=2 \" 总是显示标签栏set showcmd \" 状态栏显示目前所执行的指令set laststatus=2 \" 开启状态栏信息set cmdheight=1 \" 命令行的高度\"不显示工具/菜单栏set guioptions-=T \"工具栏 \"set guioptions-=m \"菜单栏set guioptions-=L \"左边滚动条set guioptions-=r \"右边滚动条set guioptions-=b \" 底部滚动条set guioptions-=e \" 使用内置 tab 样式而不是 guilet g:airline_powerline_fonts = 1 \"关于状态栏的配置\" 缺省自动匹配主题let g:airline_theme='base16_classic' let g:airline#extensions#tabline#enabled = 1 \" Air-line 显示上面的buffer tablet g:airline#extensions#ale#enabled = 1let g:airline#extensions#coc#enabled = 1 \"coc\"Use 24-bit (true-color) mode in Vim/Neovim when outside tmux.\"If you're usin 自动括号匹配12345678910111213141516171819202122232425262728293031323334inoremap ( ()&lt;Esc&gt;iinoremap [ []&lt;Esc&gt;iinoremap { {}&lt;Esc&gt;i autocmd Syntax html,vim inoremap &lt; &lt;lt&gt;&gt;&lt;Esc&gt;i| inoremap &gt; &lt;c-r&gt;=ClosePair('&gt;')&lt;CR&gt;inoremap ) &lt;c-r&gt;=ClosePair(')')&lt;CR&gt;inoremap ] &lt;c-r&gt;=ClosePair(']')&lt;CR&gt;inoremap } &lt;c-r&gt;=CloseBracket()&lt;CR&gt;inoremap \" &lt;c-r&gt;=QuoteDelim('\"')&lt;CR&gt;inoremap ' &lt;c-r&gt;=QuoteDelim(\"'\")&lt;CR&gt;function! ClosePair(char) if getline('.')[col('.') - 1] == a:char return \"\\&lt;Right&gt;\" else return a:char endifendffunction! CloseBracket() if match(getline(line('.') + 1), '\\s*}') &lt; 0 return \"\\&lt;CR&gt;}\" else return \"\\&lt;Esc&gt;j0f}a\" endifendffunction! QuoteDelim(char) let line = getline('.') let col = col('.') if line[col - 2] == \"\\\\\" return a:char elseif line[col - 1] == a:char return \"\\&lt;Right&gt;\" else return a:char.a:char.\"\\&lt;Esc&gt;i\" endifendf 编译、运行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374func! CompileC() \" 编译C源文件 exec \"w\" exec \"!g++ -Wall %\"endfuncfunc! CompileCpp() \" 编译C++源文件 exec \"w\" exec \"!g++ -Wall %\"endfuncfunc! Compilefortran() \" 编译fortran源文件 exec \"w\" exec \"!gfortran -Wall %\"endfunc func! RunLua() \" 运行Lua源文件 exec \"w\" exec \"!lua %\"endfuncfunc! RunPerl() \" 运行Perl源文件 exec \"w\" exec \"!perl %\"endfuncfunc! RunPython() \" 运行Python源文件 exec \"w\" exec \"!python %\"endfuncfunc! CompileCode() \" 根据文件类型自动选择相应的编译函数 exec \"w\" if &amp;filetype == \"c\" exec \"call CompileC()\" elseif &amp;filetype == \"cpp\" exec \"call CompileCpp()\" elseif &amp;filetype == \"fortran\" exec \"call Compilefortran()\" elseif &amp;filetype == \"lua\" exec \"call RunLua()\" elseif &amp;filetype == \"perl\" exec \"call RunPerl()\" elseif &amp;filetype == \"python\" exec \"call RunPython()\" endifendfuncfunc! RunResult() \" 运行可执行文件 exec \"w\" if &amp;filetype == \"c\" exec \"w\" exec \"!gcc % -Wall -std=c99 -O2 -o %&lt;.exe\" exec \"!start cmd /c \\\"\\\"%&lt;.exe\\\" &amp; pause &amp; del *.exe\\\"\" elseif &amp;filetype == \"cpp\" exec \"w\" exec \"!g++ % -Wall -std=c++11 -O2 -o %&lt;.exe\" exec \"!start cmd /c \\\"\\\"%&lt;.exe\\\" &amp; pause &amp; del *.exe\\\"\" elseif &amp;filetype == \"fortran\" exec \"w\" exec \"!gfortran % -Wall -O2 -o %&lt;.exe\" exec \"!start cmd /c \\\"\\\"%&lt;.exe\\\" &amp; pause &amp; del *.exe\\\"\" elseif &amp;filetype == \"lua\" exec \"!start cmd /c lua %&lt;.lua &amp; pause\" elseif &amp;filetype == \"perl\" exec \"!start cmd /c perl %&lt;.pl &amp; pause\" elseif &amp;filetype == \"python\" exec \"w\" exec \"!start cmd /c \\\"python %&lt;.py &amp; pause\\\"\" elseif &amp;filetype == \"markdown\" exec \"w\" exec \"MarkdownPreview\" endifendfunc\" Ctrl + f5 一键保存、编译map &lt;C-f5&gt; :call CompileCode()&lt;CR&gt; imap &lt;C-f5&gt; &lt;ESC&gt;:call CompileCode()&lt;CR&gt;vmap &lt;C-f5&gt; &lt;ESC&gt;:call CompileCode()&lt;CR&gt;\" Ctrl + b 一键保存、运行map &lt;C-b&gt; :call RunResult()&lt;CR&gt; imap &lt;C-b&gt; &lt;ESC&gt;:call RunResult()&lt;CR&gt;vmap &lt;C-b&gt; &lt;ESC&gt;:call RunResult()&lt;CR&gt; 效果图","link":"/posts/34cb7fe1/"},{"title":"L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值 -003","text":"L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值 总结使用了栈的思想，逆序输出。所以用到了递归，间接使用栈 代码1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;void R_print(LinkList &amp;L){ if(L-&gt;next!=NULL) R_print(L-&gt;next); if(L!=NULL) cout&lt;&lt;L-&gt;data&lt;&lt;endl;}void R_Ignore_Head(LinkList L){ if(L-&gt;next!=NULL) R_print(L-&gt;next);}","link":"/posts/3e29fe4e/"},{"title":"Pytorch多分类","text":"继二分类 后，通过学习 nn.CrossEntropyLoss() 、softmax() 、argmax() ，我尝试实现了下多分类模型基本工作流程。本博文主要用于整理个人的知识框架，希望也能帮到大家。如有不足，欢迎留言。🙏 运行环境：https://colab.google/ 数据准备准备数据集1234567import torchimport matplotlib.pyplot as pltfrom sklearn.datasets import make_blobsfrom sklearn.model_selection import train_test_splitX_blob, y_blob = make_blobs(n_samples = 1000, n_features = 2, centers = 4, cluster_std = 1.5, random_state = 666) make_blobs make_blobs 是 Scikit-learn 中用于生成聚类算法测试数据的函数。它能够生成多类别的高斯分布数据集，用于模拟聚类算法的数据集。 n_samples：生成的样本总数，即生成的数据点个数； n_features：生成的样本的特征数，即维度； centers：生成的类别数，或者说簇的个数，即数据点围绕几个中心点分布； random_state：随机数种子，用于控制生成的数据集的随机性，相同的随机数种子会生成相同的数据集； cluster_std：用于生成聚类数据集时设置聚类的标准差，决定了数据点在每个聚类中的分布紧密程度。标准差越小，数据点越靠近聚类中心，聚类之间的距离越小。 123# 数据类型处理X_blob = torch.from_numpy(X_blob).type(torch.float)y_blob = torch.from_numpy(y_blob).type(torch.LongTensor) # LongTensor是一个int64数据类型的值 划分数据集1X_blob_train, X_blob_test, y_blob_train, y_blob_test = train_test_split(X_blob, y_blob, test_size = 0.2, random_state = 888) 可视化123456plt.figure(figsize = (10, 7))plt.scatter(x = X_blob[:,0], y = X_blob[:,1], c = y_blob, cmap = plt.cm.RdYlBu)device = \"cuda\" if torch.cuda.is_available() else \"cpu\"--&gt;如下图 建立模型模型12345678910111213141516from torch import nnclass BlobModel(nn.Module): # hidden_units参数表示隐藏层中神经元的数量，默认值为8。 # 这个参数决定了神经网络的复杂度和性能。 # 隐藏层中的神经元数量越多，神经网络就越复杂，可以学习更复杂的模式和特征。 def __init__(self, input_features, output_features, hidden_units = 8): super().__init__() self.linear_layer_stack = nn.Sequential( nn.Linear(in_features = input_features, out_features = hidden_units), nn.ReLU(), nn.Linear(in_features = hidden_units, out_features = output_features), ) def forward(self, x): return self.linear_layer_stack(x) hidden_units def _init_(self, input_features, output_features, hidden_units = 8): hidden_units相当于一个中介，进行模型内部的变量传递。 这个参数决定了神经网络的复杂度和性能，隐藏层中的神经元数量越多，神经网络就越复杂，可以学习更复杂的模式和特征。 self.linear_layer_stack = nn.Sequential() 将多个nn.Linear() 和 ReLU() 封装在函数内部。省去return时的嵌套处理 声明模型对象123456# 模型和数据，都要保证设备的一致性model_multiclass = BlobModel(input_features = 2, output_features = 4).to(device)torch.manual_seed(666)epochs = 500X_blob_train, y_blob_train, X_blob_test, y_blob_test = X_blob_train.to(device), y_blob_train.to(device), X_blob_test.to(device), y_blob_test.to(device) 损失函数和优化器12345# 损失函数loss_fn = nn.CrossEntropyLoss() # 适用于分类的损失#SGD优化器optimizer = torch.optim.SGD(model_multiclass.parameters(), lr = 0.1) nn.CrossEntropyLoss() nn.CrossEntropyLoss() 是PyTorch中用于计算交叉熵损失的函数。[^1] 通常用于训练分类模型时，计算预测类别概率与真实类别标签之间的差异。 H(p, q) 值越小，交叉熵也越小，q与p更为接近。 如下图所示：[^2] 训练模型123456789101112131415161718192021222324252627282930for epoch in range(epochs): model_multiclass.train() # 1. forward y_logits = model_multiclass(X_blob_train) y_pred = torch.softmax(y_logits, dim = 1).argmax(dim = 1) # softmax、argmax # 2. loss = loss_fn(y_logits, y_blob_train) acc = accuracy_fn(y_true = y_blob_train, y_pred = y_pred) # 3 optimizer.zero_grad() # 4 loss.backward() # 5 optimizer.step() model_multiclass.eval() with torch.inference_mode(): test_logits = model_multiclass(X_blob_test) test_pred = torch.softmax(test_logits, dim = 1).argmax(dim = 1) test_loss = loss_fn(test_logits, y_blob_test) test_acc = accuracy_fn(y_true = y_blob_test, y_pred = test_pred) print(f\"Epoch:{epoch} | Loss:{loss:.4f}, ACC:{acc:.2f}% | Test Loss:{test_loss:.4f}, Test acc:{test_acc:.2f}%\") softmax Softmax 函数是一种常用的激活函数，通常用于神经网络模型中的多类别分类任务； 它将一个包含数字的向量转换为概率向量，其中每个值的概率与向量中每个值的相对大小成比例。该函数将返回一个 位于范围(0, 1)内 包含概率值的张量 y_pred_probs，其中每一行的和都为 1。 在这个例子中，y_logits 是模型的输出，dim = 1 表示在第二个维度上进行 softmax 计算。 softmax 与 sigmoid 的区别 1 输入不同： ​ sigmoid 应用于二分类，输入的是一维数值；而 softmax 应用于多分类，输入的是二维数组 2 输出不同 ​ sigmoid 输出一维数组，且数组元素位于 0 ~ 1 范围内； ​ softmax 输出二维数组，数组元素位于 0 ~ 1 范围内，元素含义表示 每个类别的概率，且每行和为1 argmax 函数用于返回 张量中指定维度上的最大值的索引 (即哪一类） 123456789--&gt;Epoch:492 | Loss:0.2597, ACC:86.25% | Test Loss:0.2141, Test acc:91.00%Epoch:493 | Loss:0.2592, ACC:87.50% | Test Loss:0.2080, Test acc:92.50%Epoch:494 | Loss:0.2593, ACC:86.12% | Test Loss:0.2136, Test acc:91.50%Epoch:495 | Loss:0.2589, ACC:87.50% | Test Loss:0.2078, Test acc:92.50%Epoch:496 | Loss:0.2589, ACC:86.50% | Test Loss:0.2132, Test acc:91.50%Epoch:497 | Loss:0.2585, ACC:87.38% | Test Loss:0.2077, Test acc:92.50%Epoch:498 | Loss:0.2585, ACC:86.62% | Test Loss:0.2128, Test acc:91.50%Epoch:499 | Loss:0.2582, ACC:87.38% | Test Loss:0.2075, Test acc:92.50% 发现 Test acc 达到最高后会下降 学习率太高，步子迈的太大，在最高值附近来回跳 注意： ​ 这里不是过拟合，过拟合是指，模型在训练数据上表现良好，但在测试的数据上表现不佳。过拟合可能会导致模型无法泛化到新的数据集上，因为模型在训练数据集上学习到了噪声而不是信号。 reference[^1]: 维基百科 交叉熵 相关[^2]: https://zhuanlan.zhihu.com/p/98785902 以及 评论区 杨子江 解答","link":"/posts/5a0879ec/"},{"title":"pytorch分类任务","text":"学习二分类问题的模型，熟悉逻辑损失函数、pandas.DataFrame()的基础应用。本博文主要用于整理个人的知识框架，希望也能帮到大家。如有不足，欢迎留言。🙏 Pytorch分类任务运行环境：https://colab.google/ 数据准备准备数据集123456789101112131415161718192021222324252627282930313233343536373839404142from sklearn.datasets import make_circles\"\"\"make_circles 是 scikit-learn 库中的 sklearn.datasets 模块中的一个函数。它用于生成一个带有圆形决策边界的玩具数据集。这个函数对于测试和可视化处理非线性可分数据的算法非常有用。\"\"\"n_samples = 1000X, y =make_circles(n_samples, noise = 0.03, random_state = 666)# make_circles生成的数据集通常用于二分类问题,类别标签通常是 0 或 1。生成的数据集中的每个样本都属于两个类别中的一个# y 的标签是根据每个样本点是否在大圆圈内来确定的，如果在大圆圈内则标签为 1，否则标签为 0。X.shape, y.shape # X.shape: 这将返回一个元组，描述了X数组的维度# （1000，2）二维数组，1000为行数，2为列数# （1000，） 一位数组，即labeltype(X), type(y)--&gt; (numpy.ndarray, numpy.ndarray)# 数据类型的转换# 为什么 要把numpy转为tensoar？# 统一的计算环境# 动态图 vs 静态图# 内存管理# GPU加速# 自动求导和优化器import torchX = torch.from_numpy(X)y = torch.from_numpy(y)X = X.type(torch.float)y = y.type(torch.float)\"\"\"在将 NumPy 数组转换为 PyTorch 张量时，如果没有指定数据类型，PyTorch 将会使用与原始数组相同的数据类型。因此，如果原始的 NumPy 数组中的数据类型是 float32 或 float64，那么转换后的 PyTorch 张量的数据类型也会是相应的 torch.float32 或 torch.float64。我们需要明确指定数据类型，以确保数据类型与模型和计算设备（如 GPU）的要求相匹配torch.float 实际上是 torch.float32 的别名。使用 32 位的内存空间来表示浮点数，具有较高的计算性能，通常在深度学习中被广泛使用。\"\"\" 划分数据集1234from sklearn.model_selection import train_test_splitX_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 666)# 随机20%划分完成后，X_train 和 y_train 分别包含训练集的特征数据和标签数据，X_test 和 y_test 分别包含测试集的特征数据和标签数据。 可视化pandas.DataFrame1234567891011121314import pandas as pd # 用于引入DataFramecircles = pd.DataFrame({\"X1\":X[:,0], \"X2\":X[:,1], \"label\":y})\"\"\"DataFrame 是 Pandas 中最重要的数据结构之一，它类似于电子表格或数据库表格。DataFrame 是一个二维标记数据结构，可以容纳多种类型的数据，并且每一列都可以有不同的数据类型。DataFrame 允许你以一种类似于 SQL 或 Excel 的方式轻松地对数据进行操作、筛选、分组和汇总。X[:,0] 表示取 X 中所有行的第一个特征，即将所有样本的第一个特征存储到 X1 列中。X[:,1] 表示取 X 中所有行的第二个特征，即将所有样本的第二个特征存储到 X2 列中。y 则表示样本的标签，将其存储到 label 列中。最终生成的 DataFrame circles 包含了两个特征列 X1 和 X2，以及一个标签列 label，用来存储每个样本的特征和标签信息。\"\"\"circles.head(10)--&gt;如下表 index X1 X2 label 0 0.5232532787040866 0.6130051138010815 1 1 0.5590261056027346 -0.7938079756641505 0 2 0.07279950491964153 1.0158009611913412 0 3 0.643975455169496 0.4792458217715751 1 4 0.7277505858717157 -0.3306116318780561 1 5 0.8114212398289349 -0.5947803838171337 0 6 -0.9228566785254152 -0.31323880736337917 0 7 0.8211164440168314 -0.52126486439117 0 8 -0.862636456661466 0.052975218510684215 1 9 -0.7868902607268425 0.10441672781411158 1 matplotlib.pyplot123456789101112131415import matplotlib.pyplot as pltplt.scatter(x = X[:,0], y = X[:,1], c = y, cmap = plt.cm.RdYlBu)\"\"\"这段代码使用 Matplotlib 库创建了一个散点图，其中 x 轴表示数据集中的第一个特征（X1），y 轴表示数据集中的第二个特征（X2），并根据标签（y）对点的颜色进行着色。plt.scatter() 函数用于创建散点图。x = X[:,0] 指定 x 轴的值为数据集中所有样本的第一个特征。y = X[:,1] 指定 y 轴的值为数据集中所有样本的第二个特征。c = y 指定散点的颜色根据标签 y 的值来确定。注意，此处的y表示label的y，而不是数据集的第二个特征cmap = plt.cm.RdYlBu 指定了使用的颜色映射，这里使用了红黄蓝的颜色映射。\"\"\" 建立模型模型123456789101112131415161718import torchfrom torch import nn# 确保设备一致性device = \"cuda\" if torch.cuda.is_available() else \"cpu\"class CircleModelV0(nn.Module): def __init__(self): super().__init__() # nn.Linear 是 PyTorch 中的一个类，用于创建线性（全连接）层。它的作用是将输入的数据进行线性变换 # 这种映射是复杂的的变换和映射。每个线性层都引入了一组可学习的权重参数，这些参数会在训练过程中进行调整，以使模型能够更好地拟合训练数据并进行预测。而 不是将输入的元素简单的重新按维度组合。 self.layer_1 = nn.Linear(in_features = 2, out_features = 5) # 这个线性层将输入的特征空间维度从 2 维映射到了 5 维。 self.layer_2 = nn.Linear(in_features = 5, out_features = 1) self.relu = nn.ReLU() # 激活函数引入非线性属性，从而增加神经网络的表达能力和学习能力。 def forward(self, x): # forward()定义模型的前向传播过程 return self.layer_2(self.relu(self.layer_1(x))) 声明模型对象1model_0 = CircleModelV0().to(device) 分类函数的损失函数如何来定思考：如何把预测值映射为 0 还是 1？ 使用sigmoid函数，然后将 1 / (1 + e^-x) 与0.5来比，使用torch.round()函数四舍五入。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# logistic函数，即sigmoid函数，把实数压缩到0~1# torch.nn.BCELoss() 没有经过logistic回归层\"\"\"Logistic回归是一种用于解决二分类问题的线性模型，通常用于估计样本属于某一类的概率。Logistic回归可以被视为一个单层的神经网络，其输出通过一个sigmoid函数进行转换，将线性变换的结果压缩到 (0, 1) 区间，表示样本属于某一类的概率。在PyTorch中，可以使用 nn.Linear 创建一个全连接层，然后通过 nn.Sigmoid 激活函数将线性变换的结果转换为 (0, 1) 区间的概率值。这样的组合通常被称为Logistic回归层，用于二分类问题的预测。例如，在PyTorch中，可以如下定义一个简单的Logistic回归层：import torchimport torch.nn as nnclass LogisticRegression(nn.Module): def __init__(self, input_dim): super(LogisticRegression, self).__init__() self.linear = nn.Linear(input_dim, 1) self.sigmoid = nn.Sigmoid() def forward(self, x): out = self.linear(x) out = self.sigmoid(out) return out\"\"\"# 损失函数定义loss_fn = torch.nn.BCEWithLogitsLoss() # 经过logistic回归层\"\"\"torch.nn.BCEWithLogitsLoss()这个损失函数结合了 Sigmoid 激活函数和二元交叉熵损失函数，同时计算了两者的结果使用 BCEWithLogitsLoss 可以简化代码，提高计算效率，尤其适用于二分类问题。import torchimport torch.nn as nn# 创建模型model = YourModel()# 定义损失函数criterion = nn.BCEWithLogitsLoss()# 假设预测结果和真实标签已经准备好outputs = model(inputs)loss = criterion(outputs, targets)# 清零梯度optimizer.zero_grad()# 反向传播loss.backward()# 更新参数optimizer.step()\"\"\"optimizer = torch.optim.SGD(params = model_0.parameters(), lr = 1) 辅助观察函数声明1234567# 用于计算 预测结果的一致程度def accuracy_fn(y_true, y_pred): correct = torch.sum(y_true == y_pred).item() acc = correct / len(y_true) * 100 return acc 训练模型123456789101112131415161718192021222324252627282930313233torch.manual_seed(666)epochs = 185X_train, y_train = X_train.to(device), y_train.to(device)X_test, y_test = X_test.to(device), y_test.to(device)for epoch in range(epochs): model_0.train() # 将模型设置为训练模式# squeeze()移除单维度，方便比较# 将 (1, n) 或 (n, 1) 的张量，变为 (n,) 的一维张量。有些函数可能要求输入张量的形状必须是一维的# 使用 squeeze() 可以使得代码更加简洁和清晰，避免了一些不必要的单维度，提高了代码的可读性和可维护性。 y_logits = model_0(X_train).squeeze() y_pred = torch.round(torch.sigmoid(y_logits)) # torch.sigmoid() 将y_logits变为 0 ~ 1 ，torch.round() 进行四舍五入 loss = loss_fn(y_logits, y_train) # 用去除维度后的y_logits与y_train计算损失函数 acc = accuracy_fn(y_train, y_pred) optimizer.zero_grad() loss.backward() optimizer.step() model_0.eval() # model_0.eval()和torch.inference_mode()的区别： # 都用于将模型设置为评估模式（inference mode），但它们有一些区别。 # 总的来说，model_0.eval() 更适合在模型级别进行模式切换，而 torch.inference_mode() 更适合在全局级别临时切换模式。 with torch.inference_mode(): test_logits = model_0(X_test).squeeze() test_pred = torch.round(torch.sigmoid(test_logits)) test_loss = loss_fn(test_logits, y_test) test_acc = accuracy_fn(y_test, test_pred) print(f\"{epoch} | Loss:{loss} | acc:{acc} | Test Loss:{test_loss} | Test Acc:{test_acc}\") 123456789101112131415161718192021# 输出结果--&gt;...168 | Loss:0.5972417593002319 | acc:72.125 | Test Loss:0.601545512676239 | Test Acc:71.5169 | Loss:0.595664918422699 | acc:72.5 | Test Loss:0.6001173257827759 | Test Acc:73.0170 | Loss:0.5940487384796143 | acc:73.0 | Test Loss:0.5980546474456787 | Test Acc:72.5171 | Loss:0.5923799276351929 | acc:73.5 | Test Loss:0.5966604948043823 | Test Acc:73.0172 | Loss:0.5906763076782227 | acc:74.0 | Test Loss:0.5944149494171143 | Test Acc:74.0173 | Loss:0.5889647006988525 | acc:74.375 | Test Loss:0.593086302280426 | Test Acc:75.0174 | Loss:0.5872295498847961 | acc:74.375 | Test Loss:0.5907705426216125 | Test Acc:74.0175 | Loss:0.5854421854019165 | acc:74.625 | Test Loss:0.5894856452941895 | Test Acc:76.0176 | Loss:0.5837037563323975 | acc:75.875 | Test Loss:0.5870495438575745 | Test Acc:75.5177 | Loss:0.5819454789161682 | acc:75.25 | Test Loss:0.5859463214874268 | Test Acc:76.5178 | Loss:0.580162763595581 | acc:76.25 | Test Loss:0.5832081437110901 | Test Acc:76.0179 | Loss:0.5783393979072571 | acc:76.375 | Test Loss:0.5823167562484741 | Test Acc:77.5180 | Loss:0.5764892101287842 | acc:77.625 | Test Loss:0.5792547464370728 | Test Acc:77.0181 | Loss:0.5746139883995056 | acc:76.75 | Test Loss:0.5787341594696045 | Test Acc:77.5182 | Loss:0.5727413296699524 | acc:78.5 | Test Loss:0.5753249526023865 | Test Acc:77.0183 | Loss:0.5708712339401245 | acc:77.25 | Test Loss:0.5753326416015625 | Test Acc:80.5184 | Loss:0.5689650177955627 | acc:81.875 | Test Loss:0.5713624954223633 | Test Acc:80.0...","link":"/posts/467f8fda/"},{"title":"Spawn_failed处理报告","text":"一、错误说明在上传Hexo博客到搭建到 Github 的项目时，已经使用 hexo s 预览成功了，但在 hexo d 部署到个人博客的时候出现了以下问题： 这种情况说明，Github公钥出现错误，重新添加公钥即可。 1234567公钥：使用https协议，每次pull, push都要输入密码，相当的烦。 使用git协议，然后使用ssh密钥。这样可以省去每次都输密码。公钥我们一般是给服务器的,他们到时候在权限中加入我给的公钥,然后当我从远地仓库中下载项目的时候,我在 git clone xxx 的时候，那个服务器我通过他的绑定的公钥来匹配我的私钥，这个时候,如果匹配,则就可以正常下载,如果不匹配,则失败。大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。 二、修改配置按照提示，先查看自己的博客配置文件 _config.yml ，在文件最底处修改内容如下： 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git # yourname，自己Github用户名 branch: master # 设置分支管理 三、添加公钥3.1 测试链接在博客目录，打开 Git Bash Here 输入以下代码 1ssh -T git@github.com 如下图结果，Permission denied(publickey) ，证明确实缺少公钥。 3.2 添加公钥首先在本地创建 SSH Keys 1ssh-keygen -t rsa -C \"yourmail\" # 后面为Github注册邮箱 注意在 Overwrite(y/n)? 后添加 y 后回车，其它一直回车，生成 SSH Keys根据上图找到路径 xxx/.ssh/id_rsa.pub ，打开文件，复制全部文本进入自己的Github，找到SSH/Add new，输入SSH Keys，将复制来的内容粘贴在 Key 中。保存！ 3.3 重新部署先测试SSH连接 : 1ssh -T git@github.com 成功连接！重新部署项目hexo d部署成功！(如果还是无效的话，见四) 四、ssh超时错误笔者在添加公钥的同时，设置了.ssh配置文件config中的 Port 。 1234567891011121314151617181920212223242526272829303132$ git clone git@github.com:xxxxx/xxxx.git my-awesome-projCloning into 'my-awesome-proj'...ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository.$ # This should also timeout$ ssh -T git@github.comssh: connect to host github.com port 22: Connection timed out$ # but this might work$ ssh -T -p 443 git@ssh.github.comHi xxxx! You've successfully authenticated, but GitHub does not provide shell access.$ # Override SSH settings$ vim ~/.ssh/config //没有该文件，就新建一个```# Add section below to itHost github.com Hostname ssh.github.com Port 443```$ ssh -T git@github.comHi xxxxx! You've successfully authenticated, but GitHub does not provide shell access.$ git clone git@github.com:xxxxxx/xxxxx.git my-awesome-projCloning into 'my-awesome-proj'...remote: Enumerating objects: 15, done.remote: Counting objects: 100% (15/15), done.remote: Compressing objects: 100% (14/14), done.remote: Total 15 (delta 0), reused 15 (delta 0), pack-reused 0Receiving objects: 100% (15/15), 22.90 KiB | 4.58 MiB/s, done.","link":"/posts/cc739906/"},{"title":"博客更新日志（1）","text":"本文章以日志形式记录icarus主题的更新内容。 2023/7/8尝试实现页面放大功能（完成）页面放大icarus/source/css/plus.styl # 没有就新建一个文件icarus/source/css/plus.styl &gt;folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213screen-tablet = 769pxscreen-desktop = 1088pxscreen-widescreen = 1280pxscreen-fullhd = 1472pxscreen-onek = 1700pxprimary-color = #fafafaprimary-color-hover = #71a1e0primary-color-active = #4382d6primary-color-light = rgba(93, 147, 219, 0.8)link-color = rgb(68,155,255)@media screen and (min-width: screen-onek) .container max-width: 1600px width: 1600px .column.is-3-widescreen width: 22% .column.is-6-widescreen width: 56%// Background imagebody background-color: transparentbody:before content: '' position: fixed z-index: -1 top: 0 right: 0 bottom: 0 left: 0 opacity: 0.01 transition: opacity 1s background: url(\"https://api.btstu.cn/sjbz/?lx=dongman&amp;format=images&amp;method=pc\") center 0 no-repeat background-size: cover @media screen and (max-width: screen-tablet - 1) background-image: url(\"https://api.btstu.cn/sjbz/?lx=dongman&amp;format=images&amp;method=mobile\")body.ready:before opacity: 1// Nav bar fixes.navbar background-color: rgba(255,255,255,0.8) backdrop-filter: blur(10px) -webkit-backdrop-filter: blur(10px).navbar-main .navbar-menu background-color: transparent .navbar-item &amp;.is-active color: #3273dc font-weight: bold &amp;:hover color: #3273dc background-color: primary-color @media screen and (min-width: screen-desktop) .navbar-menu .navbar-start margin-left: 2em @media screen and (max-width: screen-tablet - 1) .navbar-menu flex-direction: column .navbar-start .navbar-end justify-content: center overflow-x: auto .navbar-item padding: .5rem .navbar-end padding-bottom: .5rem// Card fixes.card overflow: visible transition: background-color 0.5s ease background-color: rgba(255,255,255,0.95) &amp;:hover background-color: rgba(255,255,255,1) &amp;.card-transparent background-color: transparent !important .level-start, .level-end overflow: hidden@media screen and (min-width: screen-tablet) .column-main, .column-left, .column-right, .column-right-shadow &amp;.is-sticky top: 10px// Article horizontal scroll bar.article .content overflow: auto// Footer fixesfooter.footer background-color: transparent.footer backdrop-filter: blur(10px) -webkit-backdrop-filter: blur(10px) position: relative &amp;:before content: '' position: absolute top: 0 left: 0 width: 100% height: 100% background-color: rgba(255,255,255,0.8).footer-logo img max-height: 2rem.footer a:not(.button) color: inherit &amp;:hover text-decoration: underline// Section fixes.section .container .columns -webkit-justify-content: center justify-content: center// Selection::selection color: white background-color: primary-color-light::-moz-selection color: white background-color: primary-color-light// Colorsa color: link-color.button.is-link background-color: primary-colorarticle.article .article-meta overflow-y: hidden .title width: fit-content img max-height: 800pxarticle .title a background-image: linear-gradient(transparent calc(100% - 1px), primary-color 1px) background-repeat: no-repeat background-size: 0 100% transition: all .25s ease-in-out .title:hover a // override another !important color: primary-color !important background-size: 100% 100%.button.is-link:hover, .button.is-link.is-hovered background-color: primary-color-hover.button.is-link:active, .button.is-link.is-active background-color: primary-color-active.pagination-link.is-current background-color: primary-color border-color: primary-color-active// Fix fontawsome icon 不等宽.navbar-main .navbar-menu .navbar-end .navbar-item min-width 35px justify-content: center -webkit-justify-content: center// 版权声明.article-licensing z-index: 0#busuanzi_container_page_pv display: none !important.card .v .vlist .vcard .vcontent text-align: inherit.searchbox .searchbox-pinyin display: flex align-items: center user-select: none input vertical-align: middle span position: relative top: 1px.button.link-more margin-top 0.75rem.post-navigation .level-item flex-shrink: 1.twikoo-new-content display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;// animals.symbolic-animals color: #3273dc icarus/source/style.styl #在该文件最后添加icarus/source/style.styl &gt;folded1@import \"plus\" 2023/7/9尝试实现toc的侧边栏显示功能toc侧边栏显示功能在文章头部加入toc: true 尝试实现文章页面两栏放大文章页面放大两栏icarus中可能没有_config.post.yml，需要自己新建文件夹。icarus 5.0.0版本后，配置文件通常放在主题文件外面需要注意。 设置文章页面为双栏目在Blog文件下，新建**_config.post.yml**。把需要的widget显示到一边，可以参考官方文档Icarus用户指南 - 主题配置 - Icarus (ppoffice.github.io) 修改icarus主题下layout文档（Icarus/layout/layout.jsx）注意： 减号(-)：删除这一行 加号(+)：添加这一行 Icarus/layout/layout.jsx &gt;folded1234 &lt;Head site={site} config={config} helper={helper} page={page} /&gt;- &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; Icarus/layout/layout.jsx &gt;folded1234 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 修改widgets.jsx (layout/common/widgets.jsx)layout/common/widgets.jsx &gt;folded12345678 function getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } 优化不同屏幕下的宽度(include/style/responsive.styl)include/style/responsive.styl &gt;folded1234567891011121314151617 +widescreen()+ .is-3-column .container+ max-width: $widescreen - $gap+ width: $widescreen - $gap+ .is-1-column .container, .is-2-column .container max-width: $desktop - 2 * $gap width: $desktop - 2 * $gap +fullhd()+ .is-3-column .container+ max-width: $fullhd - 2 * $gap+ width: $fullhd - 2 * $gap+ .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap 参考文献：[1] https://www.alphalxy.com/2019/03/customize-icarus/ [2] Icarus用户指南 - 主题配置 - Icarus (ppoffice.github.io) //此后的博客主题完善过程，将以日期分为多个文章记录","link":"/posts/c4442e98/"},{"title":"博客更新日志（2）","text":"实现左侧栏滑动的同时，目录黏附顶端原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 source/js/main.js &gt;folded123 if ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); include/style/widget.styl &gt;folded123+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll 参考文献：[1] https://www.alphalxy.com/2019/03/customize-icarus/","link":"/posts/154f879f/"},{"title":"设单链表的表头指针为L，结点由data，next构成，设计算法判断该链表的全部n个字符是否中心对称。如xyx、xyyx -007","text":"设单链表的表头指针为L，结点由data，next构成，设计算法判断该链表的全部n个字符是否中心对称。如xyx、xyyx 总结算法思想：​ 使用栈来判断链表中的数据是否对称。先让前一半元素依次进栈。在处理链表的后一半元素时，当访问到链表的一个元素后，就从链表中弹出一个元素。按循环后数组下标来判断，是否对称 代码编写注意点：​ 1、数组下标从0开始，前一半元素下标是从0 &lt;= i &lt; n/2 ​ 2、判断元素个数为奇数 n%2==1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//设单链表的表头指针为L，结点由data，next构成，设计算法判断该链表的全部n个字符是否中心对称。如xyx、xyyx#include &lt;iostream&gt;using namespace std;typedef struct LNode { char data; struct LNode* next;}LNode, * LinkList;//参考答案int dc(LinkList L,int n){ int i; char s[n/2]; //s为字符栈 LNode *p=L-&gt;next; //p为工作指针，指向待处理的当前元素 for(i=0;i&lt;n/2;i++){ //链表前一半元素进栈，注意由于是数组，下标从零开始。所以i&lt;n/2 s[i]=p-&gt;data; p=p-&gt;next; } i--; //恢复最后的i值 if(n%2==1) //元素个数为奇数，移过中心点 p=p-&gt;next; while(p!=NULL&amp;&amp;s[i]==p-&gt;data){ i--; p=p-&gt;next; } if(i==-1) return 1; //对称 else return 0; //不对称}//自己写的代码bool dc(LinkList L, int n) { char* a = new char[n]; int i = 0, j = n - 1; //i,j 作为数组两端的工作指针 LNode* p = L-&gt;next; //作为遍历单链表的工作指针 int k=0; //字符转移 while (p != NULL) { a[k] = p-&gt;data; p = p-&gt;next; k++; } while (j - i &gt; 0) { if (a[i] == a[j]) { i++; j--; } else { cout &lt;&lt; \"错误\"; return false; } } delete[] a; return true;}int main() { LinkList L; L = new LNode; L-&gt;next = NULL; int n = 3; LNode* a, * b, * c; a = new LNode; b = new LNode; c = new LNode; a-&gt;data = 'x'; b-&gt;data = 'y'; c-&gt;data = 'y'; L-&gt;next=a; a-&gt;next=b; b-&gt;next=c; c-&gt;next = NULL; cout &lt;&lt; dc(L, n) &lt;&lt; endl; delete L; delete a; delete b; delete c; system(\"pause\"); return 0;}","link":"/posts/521b9f65/"},{"title":"conda 配置问题汇总","text":"macbook air到了，记录一下配置conda环境中遇到的问题。 1 zsh: command not found: condaMacOSMacOS zsh: command not found: conda 解决方案_mac zsh:1: command not found: conda-CSDN博客 在 .zshrc 默认文件中添加 conda 的默认路径 1export PATH=\"/opt/anaconda3/bin:$PATH\" 1source .zshrc 然后重启终端即可 2 CondaError: Run ‘conda init’ before ‘conda activate’MacOS【Linux】在Linux上使用Conda报错：CondaError: Run ‘conda init‘ before ‘conda activate‘_condaerror: run ‘conda init’ before ‘conda activat-CSDN博客 当在终端中使用一下命令时： 1conda activate base 出现一下错误： 1CondaError: Run 'conda init' before 'conda activate' 这是因为conda的启动文件没有运行 1source .bash_profile zsh是mac的默认终端，所以可以把上面命令直接写入 .zshrc 文件 1source .bash_profile 打开终端，则默认启用conda","link":"/posts/eabd0964/"},{"title":"二分查找","text":"第一题题目描述给定一个按照升序排列的长度为 n的整数数组，以及 q个查询。 对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 00 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式第一行包含整数 n 和 q，表示数组长度和询问个数。 第二行包含 n个整数（均在 1∼10000 范围内），表示完整数组。 接下来 q 行，每行包含一个整数 k，表示一个询问元素。 输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围1≤n≤1000001≤q≤100001≤k≤10000 输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 代码描述1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;const int N=1e6+10;int a[N];int main(){ int n,q,k; scanf(\"%d%d\",&amp;n,&amp;q); for(int i=0;i&lt;n;i++) { scanf(\"%d\",&amp;a[i]); } for(int i=0;i&lt;q;i++) { scanf(\"%d\",&amp;k); int l=0,r=n-1; //第一个a[l]=k，查找最左边的位置 while(l&lt;r) { int mid=l+r&gt;&gt;1; if(a[mid]&gt;=k) r=mid; else l=mid+1; } //如果该值，不是 if(a[l]!=k) cout&lt;&lt;\"-1 -1\"&lt;&lt;endl; else //查找最后一个k（最右边的位置）， { cout&lt;&lt;l&lt;&lt;\" \"; l=0,r=n-1; while(l&lt;r) { int mid=1+r+1&gt;&gt;1; if(a[mid]&lt;=k) l=mid; else r=mid-1; } cout&lt;&lt;l&lt;&lt;endl; } } return 0;} 思路解析用二分去查找元素，要求数组的有序性或者拥有类似于有序的性质。所以写之前，就要考虑好想要查找的是什么。 就本题而言，一个包含重复元素的有序序列，要求输出某元素出现的起始位置和终止位置。所以，需要写两个二分，一个需要找到 &gt;= x 的第一个数，另一个需要找到 &lt;= x 的最后一个数。 二分查找的两套模板（如下图所示）： 1234567891011121314151617181920212223242526bool check(int x) {/* ... */} // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：//找的是左边界int bsearch_1(int l, int r){ while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质，q[mid]&gt;=x else l = mid + 1; } return l;}// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：//即找的是右边界int bsearch_2(int l, int r){ while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; //+1是为了防止死循环，如[1,1]区间，true时 if (check(mid)) l = mid; //q[mid]&lt;=x else r = mid - 1; } return l;} 第一套，查找的是左边界；第二套，查找的是右边界。","link":"/posts/e8eb0481/"},{"title":"井字棋（人机对战）","text":"基于pygame实现的井字棋（人机对战）游戏 这款井字棋小游戏中，你将对战很笨的人工智能NanaGo。后续有时间将会对AI内部函数进行完善，make NanaGo great again。 AI内部函数这个ai很笨，只会按照顺序落子。他的核心逻辑就只是for循环。 1234567891011def __computer_chess(self): \"\"\" 电脑下棋。从左上角开始依次遍历，然后下到第一个empty的地方 \"\"\" for c in range(3): for r in range(3): if self.__chess_map[r][c] == ChessType.EMPTY: self.__chess_map[r][c] = ChessType.FORK return 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414import enumimport randomfrom typing import List, Tuple, Optionalimport pygame # 需先手动下载pygame库：pip install pygameBG_COLOR = pygame.Color(\"#EEEEEE\") # 背景BOARD_COLAR = pygame.Color(\"#E96666\") # 边框CIRCLE_CHESS_COLOR = pygame.Color(\"#3CA273\") # 画圈圈的棋子的颜色FORK_CHESS_COLOR = pygame.Color(\"#5570C2\") # 画叉的棋子的颜色WIN_LINE_COLOR = pygame.Color(\"#FFA801\") # 获胜划线CIRCLE_WIN_HINT_TEXT_COLOR = pygame.Color(\"#029999\") # 画圈获胜文本FORK_WIN_HINT_TEXT_COLOR = pygame.Color(\"#E94466\") # 画叉获胜文本TIE_HINT_TEXT_COLOR = pygame.Color(\"#FAC888\") # 平局文本RESTART_HINT_TEXT_COLOR = pygame.Color(\"#91CBBB\") #重新开始def main(): # 初试化 pygame.init() pygame.display.set_caption(\"井字棋AI_NanaGo\") screen = pygame.display.set_mode((500,500)) clock = pygame.time.Clock() scene = GameScene() while True: for event in pygame.event.get(): # 退出判断 if event.type == pygame.QUIT: pygame.quit() return # 处理鼠标的输入，传递到我的场景中进行处理 if event.type == pygame.MOUSEBUTTONDOWN: if event.dict[\"button\"] == pygame.BUTTON_LEFT: pos = event.dict[\"pos\"] #pos is a tuple scene.on_mouse_left_button_down(pos[0], pos[1]) elif event.type == pygame.MOUSEMOTION: #鼠标移动 pos = event.dict[\"pos\"] #pos is a tuple scene.on_mouse_motion(pos[0], pos[1]) #绘制场景 scene.draw(screen) #更新屏幕 pygame.display.flip() #限制帧率 clock.tick(30) class ChessType(enum.Enum): \"\"\" 棋子类型，画圈圈的是人类，画叉的是电脑AI \"\"\" EMPTY = 0 \"\"\"空位，没有被下子\"\"\" CIRCLE = 1 FORK = 2class GameStatus(enum.Enum): \"\"\" 游戏状态 \"\"\" PLAYING = 0 CIRCLE_WIN = 1 FORK_WIN = 2 TIE = 3 \"\"\"平局\"\"\"class GameScene: \"\"\" 游戏场景 \"\"\" __game_status: GameStatus = None __chess_map: List[List[ChessType]] = None __curr_mouse_down_pos: Optional[Tuple[int, int]] = None __curr_mouse_motion_pos: Optional[Tuple[int, int]] = None __win_pos_start: Optional[Tuple[int, int]] = None __win_pos_end: Optional[Tuple[int, int]] = None __circle_win_hint_text: pygame.Surface = None __fork_win_hint_text: pygame.Surface = None __tie_hint_text: pygame.Surface = None __restart_text: pygame.Surface = None def __init__(self): font = pygame.font.Font(pygame.font.get_default_font(), 25) self.__circle_win_hint_text = font.render(\"You Win\", True, CIRCLE_WIN_HINT_TEXT_COLOR) self.__fork_win_hint_text = font.render(\"NanaGo Win\", True, FORK_WIN_HINT_TEXT_COLOR) self.__tie_hint_text = font.render(\"Tie\", True, TIE_HINT_TEXT_COLOR) self.__restart_text = font.render(\"Click for a new game\", True, RESTART_HINT_TEXT_COLOR) self.__init() def __init(self): print(\"初始化ing\") self.__game_status = GameStatus.PLAYING self.__chess_map = [ [ChessType.EMPTY,ChessType.EMPTY,ChessType.EMPTY], [ChessType.EMPTY,ChessType.EMPTY,ChessType.EMPTY], [ChessType.EMPTY,ChessType.EMPTY,ChessType.EMPTY] ] self.__curr_mouse_down_pos = None self.__win_pos_start = None self.__win_pos_end = None if random.random() &gt; 0.5: print(\"电脑先手\") self.__computer_chess() self.__check_game_over() else: print(\"人类先手\") def __computer_chess(self): \"\"\" 电脑下棋。从左上角开始依次遍历，然后下到第一个empty的地方 \"\"\" for c in range(3): for r in range(3): if self.__chess_map[r][c] == ChessType.EMPTY: self.__chess_map[r][c] = ChessType.FORK return def __check_game_over(self): for c in range(3): circle_count = 0 fork_count = 0 for r in range(3): if self.__chess_map[r][c] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[r][c] == ChessType.FORK: fork_count += 1 if circle_count == 3: self.__game_status = GameStatus.CIRCLE_WIN self.__win_pos_start = (0, c) self.__win_pos_end = (2, c) print(\"人类获胜\") break if fork_count == 3: self.__game_status = GameStatus.FORK_WIN self.__win_pos_start = (0, c) self.__win_pos_end = (2, c) print(\"电脑获胜\") break if self.__game_status != GameStatus.PLAYING: return for r in range(3): circle_count = 0 fork_count = 0 for c in range(3): if self.__chess_map[r][c] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[r][c] == ChessType.FORK: fork_count += 1 if circle_count == 3: self.__game_status = GameStatus.CIRCLE_WIN self.__win_pos_start = (r, 0) self.__win_pos_end = (r, 2) print(\"人类获胜\") break if fork_count == 3: self.__game_status = GameStatus.FORK_WIN self.__win_pos_start = (r, 0) self.__win_pos_end = (r, 2) print(\"电脑获胜\") break if self.__game_status != GameStatus.PLAYING: return if self.__chess_map[0][0] == ChessType.CIRCLE and self.__chess_map[1][1] == ChessType.CIRCLE and self.__chess_map[2][2] == ChessType.CIRCLE: self.__game_status = GameStatus.CIRCLE_WIN self.__win_pos_start = (0,0) self.__win_pos_end = (2,2) elif self.__chess_map[0][0] == ChessType.FORK and self.__chess_map[1][1] == ChessType.FORK and self.__chess_map[2][2] == ChessType.FORK: self.__game_status = GameStatus.FORK_WIN self.__win_pos_start = (0,0) self.__win_pos_end = (2,2) elif self.__chess_map[2][0] == ChessType.CIRCLE and self.__chess_map[1][1] == ChessType.CIRCLE and self.__chess_map[0][2] == ChessType.CIRCLE: self.__game_status = GameStatus.CIRCLE_WIN self.__win_pos_start = (2,0) self.__win_pos_end = (0, 2) elif self.__chess_map[2][0] == ChessType.FORK and self.__chess_map[1][1] == ChessType.FORK and self.__chess_map[0][2] == ChessType.FORK: self.__game_status = GameStatus.FORK_WIN self.__win_pos_start = (2,0) self.__win_pos_end = (0,2) if self.__game_status != GameStatus.PLAYING: return has_empty = False for r in range(3): for c in range(3): if self.__chess_map[r][c] == ChessType.EMPTY: has_empty = True break if has_empty == True: break if not has_empty: self.__game_status == GameStatus.TIE def __get_mouse_on_board_pos(self, board_pos: Tuple[int, int], cell_size: int, mouse_pos:Tuple[int, int]) -&gt;Tuple[int, int]: \"\"\" 获取当前鼠标位置在棋盘中的行列位置(index)(eg(0,0)(0,1)(0,2),...(2,0)(2,1)(2,2))，鼠标没有在棋盘中返回(-1,-1) \"\"\" assert self #为了防止报错或者warning board_x, board_y = board_pos[0], board_pos[1] mouse_x, mouse_y = mouse_pos[0], mouse_pos[1] x, y = mouse_x - board_x, mouse_y - board_y #用相对距离 if x &lt; 0 or y &lt; 0 or x &gt;= cell_size * 3 or y &gt;= cell_size * 3: return -1, -1 # 竖直方向表示行，水平方向表示列 return y // cell_size, x // cell_size def on_mouse_left_button_down(self, pos_x: int, pos_y: int): \"\"\" 鼠标左键按下 \"\"\" self.__curr_mouse_down_pos = (pos_x, pos_y) def on_mouse_motion(self, pos_x:int, pos_y:int): self.__curr_mouse_motion_pos = (pos_x, pos_y) def draw(self, screen: pygame.Surface): #填充背景 screen.fill(BG_COLOR) #绘制棋盘 board_cell_size = 100 board_x = round(screen.get_width() / 2 - (3 * board_cell_size) / 2) board_y = round(screen.get_height() / 2 - (3 * board_cell_size) / 2) self.__draw_board(screen, (board_x,board_y),board_cell_size,3) # 如果处于游戏中，判断鼠标（人类）是否有落子 if self.__game_status == GameStatus.PLAYING and self.__curr_mouse_down_pos: row, col = self.__get_mouse_on_board_pos((board_x, board_y), board_cell_size, self.__curr_mouse_down_pos) # 人类落子 self.__chess_map[row][col] = ChessType.CIRCLE print(f\"人类(点击落子):({row}, {col}) &lt;- 圈\") self.__check_game_over() if self.__game_status == GameStatus.PLAYING: self.__computer_chess() self.__check_game_over() self.__curr_mouse_down_pos = None if self.__game_status != GameStatus.PLAYING and self.__curr_mouse_down_pos: self.__init() self.__draw_chess(screen, (board_x,board_y),board_cell_size,20,5) self.__draw_win_line(screen, (board_x,board_y),board_cell_size,3) self.__draw_hint_text(screen, (board_x,board_y),board_cell_size) def __draw_board(self, screen:pygame.Surface, board_pos:Tuple[int, int], cell_size:int, line_width:int): \"\"\" 绘制棋盘 \"\"\" assert self x, y = board_pos[0], board_pos[1] #横线 x1 = x x2 = x + 3 * cell_size y1 = y + cell_size y2 = y + 2 * cell_size pygame.draw.line(screen,BOARD_COLAR,(x1,y1),(x2, y1),line_width) pygame.draw.line(screen,BOARD_COLAR,(x1,y2),(x2, y2),line_width) y1 = y y2 = y + 3 * cell_size x1 = x + cell_size x2 = x + 2 * cell_size pygame.draw.line(screen,BOARD_COLAR,(x1,y1),(x1, y2),line_width) pygame.draw.line(screen,BOARD_COLAR,(x2,y1),(x2, y2),line_width) def __draw_chess(self, screen:pygame.Surface, board_pos:Tuple[int,int], board_cell_size:int, padding:int, border_width:int): \"\"\" 绘制棋子 \"\"\" board_x, board_y = board_pos[0], board_pos[1] for r in range(len(self.__chess_map)): row = self.__chess_map[r] for c in range(len(row)): chess = row[c] if chess == ChessType.CIRCLE: self.__draw_circle_chess(screen, (board_x + c * board_cell_size, board_y + r * board_cell_size), board_cell_size, padding, border_width) elif chess == ChessType.FORK: self.__draw_fork_chess(screen, (board_x + c * board_cell_size, board_y + r * board_cell_size), board_cell_size, padding, border_width) def __draw_circle_chess(self, screen:pygame.Surface, chess_pos:Tuple[int,int], board_cell_size:int, padding:int, border_width:int): \"\"\" 绘制圆棋子 \"\"\" assert self chess_x, chess_y = chess_pos[0], chess_pos[1] center = round(chess_x + board_cell_size / 2), round(chess_y + board_cell_size / 2) radius = round(board_cell_size / 2 - padding) pygame.draw.circle(screen, CIRCLE_CHESS_COLOR, center, radius, border_width) def __draw_fork_chess(self, screen:pygame.Surface, chess_pos:Tuple[int,int], board_cell_size:int, padding:int, border_width:int): \"\"\" 绘制叉棋子 \"\"\" assert self chess_x, chess_y = chess_pos[0], chess_pos[1] pygame.draw.line(screen, FORK_CHESS_COLOR, (chess_x + padding, chess_y + padding), (chess_x + board_cell_size - padding, chess_y + board_cell_size - padding ), border_width) pygame.draw.line(screen, FORK_CHESS_COLOR, (chess_x + board_cell_size - padding, chess_y + padding), (chess_x + padding, chess_y + board_cell_size - padding ), border_width) def __draw_win_line(self, screen:pygame.Surface, board_pos:Tuple[int,int], cell_size:int, line_width:int): \"\"\" 绘制获胜曲线 \"\"\" if (not self.__win_pos_start) or (not self.__win_pos_end): return board_x, board_y = board_pos[0], board_pos[1] pos_start_row, pos_start_col = self.__win_pos_start[0], self.__win_pos_start[1] pos_end_row, pos_end_col = self.__win_pos_end[0], self.__win_pos_end[1] half_cell_size = round(cell_size / 2) start = (board_x + pos_start_col * cell_size + half_cell_size, board_y + pos_start_row * cell_size + half_cell_size) end = (board_x + pos_end_col * cell_size + half_cell_size, board_y + pos_end_row * cell_size + half_cell_size) pygame.draw.line(screen, WIN_LINE_COLOR, start, end, line_width) def __draw_hint_text(self, screen:pygame.Surface, board_pos:Tuple[int,int], cell_size:int, ): board_y = board_pos[1] if self.__game_status == GameStatus.CIRCLE_WIN: screen.blit(self.__circle_win_hint_text, (screen.get_width() / 2 - self.__circle_win_hint_text.get_width() / 2, board_y / 2 - self.__circle_win_hint_text.get_height() / 2)) elif self.__game_status == GameStatus.FORK_WIN: screen.blit(self.__fork_win_hint_text, (screen.get_width() / 2 - self.__fork_win_hint_text.get_width() / 2, board_y / 2 - self.__fork_win_hint_text.get_height() / 2)) elif self.__game_status == GameStatus.TIE: screen.blit(self.__tie_hint_text, (screen.get_width() / 2 - self.__tie_hint_text.get_width() / 2, board_y / 2 - self.__tie_hint_text.get_height() / 2)) if self.__game_status != GameStatus.PLAYING: #重新开始的提示 screen.blit(self.__restart_text, (screen.get_width() / 2 - self.__restart_text.get_width() / 2, (screen.get_height() + (board_y + cell_size * 3)) / 2 - self.__restart_text.get_height() / 2))if __name__ == \"__main__\": main()","link":"/posts/61a28051/"},{"title":"pytorch工作流","text":"初学机器学习，从线性回归入手，了解机器学习的基本工作流程，从而进一步理解深度学习模型训练的本质。本博文主要用于整理个人的知识框架，希望也能帮到大家。如有不足，欢迎留言。🙏 Pytorch工作流运行环境：https://colab.google/ 将一般Pytorch机器学习的工作流程划分为：数据准备、建立模型、训练模型、预测这四个部分 数据准备准备数据集1234567891011import torch# y = 0.7 * x + 0.3 (一系列散点)weight = 0.7bias = 0.3# Create datastart = 0end = 1step = 0.02X = torch.arange(start,end, step)y = weight * X +bias 123456789101112131415X # --&gt;表示单步运行结果--&gt;tensor([0.0000, 0.0200, 0.0400, 0.0600, 0.0800, 0.1000, 0.1200, 0.1400, 0.1600, 0.1800, 0.2000, 0.2200, 0.2400, 0.2600, 0.2800, 0.3000, 0.3200, 0.3400, 0.3600, 0.3800, 0.4000, 0.4200, 0.4400, 0.4600, 0.4800, 0.5000, 0.5200, 0.5400, 0.5600, 0.5800, 0.6000, 0.6200, 0.6400, 0.6600, 0.6800, 0.7000, 0.7200, 0.7400, 0.7600, 0.7800, 0.8000, 0.8200, 0.8400, 0.8600, 0.8800, 0.9000, 0.9200, 0.9400, 0.9600, 0.9800]) y--&gt;tensor([0.3000, 0.3140, 0.3280, 0.3420, 0.3560, 0.3700, 0.3840, 0.3980, 0.4120, 0.4260, 0.4400, 0.4540, 0.4680, 0.4820, 0.4960, 0.5100, 0.5240, 0.5380, 0.5520, 0.5660, 0.5800, 0.5940, 0.6080, 0.6220, 0.6360, 0.6500, 0.6640, 0.6780, 0.6920, 0.7060, 0.7200, 0.7340, 0.7480, 0.7620, 0.7760, 0.7900, 0.8040, 0.8180, 0.8320, 0.8460, 0.8600, 0.8740, 0.8880, 0.9020, 0.9160, 0.9300, 0.9440, 0.9580, 0.9720, 0.9860]) 划分数据集1234567# train/test splittrain_split = int(0.8 * len(X)) # 8:2的划分X_train, y_train = X[:train_split], y[:train_split] #左闭右开X_test, y_test = X[train_split:], y[train_split:]len(X_train), len(y_train), len(X_test), len(y_test)--&gt;(40, 40, 10, 10) 可视化1234567891011import matplotlib.pyplot as plt #import as 为引入模块并起别名def plot_predictions(train_data = X_train, train_labels = y_train, test_data = X_test, test_labels = y_test, predictions = None): plt.figure(figsize = (10, 7)) # 图像大小 plt.scatter(train_data, train_labels, c = \"b\", s = 4, label = \"Training data\") # s = 4, 为指定散点的直径，大约为4个点 plt.scatter(test_data, test_labels, c = \"g\", s = 4, label = \"Test Data\") if predictions is not None: plt.scatter(test_data, predictions, c= \"r\", s = 4, label = \"Prediction\") plt.legend(prop = {\"size\":14}) # 图例的属性，其中 size 参数指定了图例中文本的大小为 14 磅plot_predictions() 12plot_predictions()--&gt; 建立模型1234567891011121314from torch import nnclass LinearRegressionModel(nn.Module): #这个类继承自 nn.Module 类，这是 PyTorch 中定义神经网络模型的基类。 def __init__(self): super().__init__() # nn.Parameter 是 PyTorch 中的一个类，用于将张量（tensor）封装为可学习的模型参数, # 这些参数将被自动地添加到模型的参数列表中，并能够被优化器识别和更新,并使得其具有梯度计算和自动求导的功能。 # 在神经网络中，模型参数通常表示为权重和偏置，它们需要在训练过程中通过梯度下降等优化算法进行更新。 self.weights = nn.Parameter(torch.randn(1, dtype = torch.float), requires_grad = True) #requires_grad = true 表示用于梯度计算,以便在训练过程中更新它们的值。 self.bias = nn.Parameter(torch.randn(1,dtype = torch.float), requires_grad = True) # 我们定义了两个参数：权重（weights）和偏置（bias），它们都是可学习的模型参数，用于线性回归模型中的线性部分。 # 这些参数通过 nn.Parameter 函数封装为模型参数，从而使得它们可以被优化器更新。 def forward(self, x:torch.tensor): #x:torch.tensor标识注释(免责声明)， 不强制，也可以接受其他类型， -&gt;torch.tensor也表示注释，意为最后得到的数据类型 return self.weights * x + self.bias 12345678910111213141516171819202122torch.manual_seed(666) # 做个种子，保证伪随机的一致性model_0 = LinearRegressionModel() # model_0 赋为一个具有相应类属性的对象# 注意model_0没有在训练模型处声明，所以每次调参训练结果会追加。所以在google colab中每次调参重新训练，应该从这里开始。model_0.parameters()# model_0.parameters() 用于获取神经网络模型 model_0 中的所有模型参数。# 在 PyTorch 中，模型参数通常是由 nn.Parameter 类型的对象表示的，它们存储了模型的权重和偏置等可学习的参数。# model_0.parameters() 返回一个迭代器，通过迭代器可以依次访问模型中的每一个参数。这个迭代器通常用于将模型的参数传递给优化器，以便在训练过程中更新参数。--&gt;&lt;generator object Module.parameters at 0x7a74a42ae7a0&gt;# 如果想print一个东西，但是打印出类似于&lt;generator object Module.parameters at 0x79fc67df00b0&gt;# 则强制类型转换为listlist(model_0.parameters())--&gt;[Parameter containing: tensor([-2.1188], requires_grad=True), Parameter containing: tensor([0.0635], requires_grad=True)]model_0.state_dict() # 另一种得到他的参数的方式 用于返回模型的参数字典（state dictionary）。这个字典包含了模型中所有可学习参数的名称及其对应的张量值。--&gt;OrderedDict([('weights', tensor([-2.1188])), ('bias', tensor([0.0635]))]) 训练模型1234567891011121314151617### 训练一个模型### loss function ，损失函数值，越大，数据越乱。用于度量y_pred和y_test之间的差距# MAE 3 4 5; 2 6 4 = 1.33# MSE 3 4 5; 2 6 4 = 2# 两种比较方式，每种参数只和自己比### optimizer ，告诉我们的模型怎样朝向正确的参数走过去\"\"\"由于google colab是单步运行，所以每次调参后，应该从建立model_0处重新向后运行\"\"\"loss_fn = nn.L1Loss() #MAE,# nn.L1Loss() 是 PyTorch 中的一个损失函数，用于计算预测值和目标值之间的平均绝对误差（Mean Absolute Error，MAE）。# torch.optim.SGD: 这是 PyTorch 中的随机梯度下降优化器的类。它实现了随机梯度下降算法，用于更新模型的参数以最小化损失函数。这个优化器需要指定要优化的参数和学习率等超参数。optimizer = torch.optim.SGD(params = model_0.parameters(), lr = 0.1) #lr 怎么调（跑了一个模型后观察一下，曲线平，则加大10倍），一般0.01、0.1没问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748epochs = 100train_loss_values = []test_loss_values = []epoch_count = []for epoch in range(epochs): # Put model in training mode: model_0.train() # 1. forward pass, using forward function y_pred = model_0(X_train) # 2. Calculate loss loss = loss_fn(y_pred, y_train) # 3. zero_grad 在每一次迭代中，我们都需要在反向传播之前将梯度归零， #这是因为 PyTorch 默认会在进行梯度计算时，将新计算得到的梯度累加到已存在的梯度上， #而我们希望每次迭代都是独立的。因此，使用 optimizer.zero_grad() 就可以很方便地实现这一步骤。 optimizer.zero_grad() # 4. back prop 梯度计算 loss.backward() # 5. Progress optimizer 更新梯度 optimizer.step() # 6. 调用 model_0.eval() 将模型切换到评估模式（不会梯度计算）。 model_0.eval() with torch.inference_mode(): test_pred = model_0(X_test) epoch_count.append(epoch) test_loss = loss_fn(test_pred, y_test.type(torch.float)) train_loss_values.append(loss.detach().numpy()) # loss.detach().numpy() 将 PyTorch 张量转换为 NumPy 数组时，通常是为了利用 NumPy 提供的丰富功能进行数据处理、分析或者可视化。 test_loss_values.append(test_loss.detach().numpy()) print(f\"Epoch:{epoch} | Train Loss:{loss} | Test Loss:{test_loss}\") --&gt;Epoch:0 | Train Loss:1.3358044624328613 | Test Loss:2.610489845275879Epoch:1 | Train Loss:1.2205944061279297 | Test Loss:2.4757800102233887Epoch:2 | Train Loss:1.1053844690322876 | Test Loss:2.3410699367523193Epoch:3 | Train Loss:0.9938250780105591 | Test Loss:2.216449022293091Epoch:4 | Train Loss:0.9000433683395386 | Test Loss:2.097005844116211Epoch:5 | Train Loss:0.8182994723320007 | Test Loss:1.9881856441497803Epoch:6 | Train Loss:0.7505138516426086 | Test Loss:1.8903448581695557...... 123456789# 绘图plt.plot(epoch_count, train_loss_values, label = \"Train Loss\")plt.plot(epoch_count, test_loss_values, label = \"Test Loss\")plt.title(\"Training and test loss curves\")plt.ylabel(\"Loss\")plt.xlabel(\"Epochs\")plt.legend() 预测123456789101112model_0.eval() #评价模式with torch.inference_mode(): #做预测 y_preds = model_0(X_test)y_preds--&gt;tensor([0.5704, 0.5693, 0.5683, 0.5672, 0.5661, 0.5650, 0.5639, 0.5629, 0.5618, 0.5607])model_0.state_dict()--&gt;OrderedDict([('weights', tensor([-0.0539])), ('bias', tensor([0.6135]))])plot_predictions(predictions = y_preds) 保存模型与数据读取12345678910111213141516171819# 保存模型到google 云端硬盘from pathlib import PathMODEL_PATH = Path(\"models\")MODEL_PATH.mkdir(parents = True, exist_ok = True)MODEL_NAME = \"pytorch_workflow_model_0.pth\"MODEL_SAVE_PATH = MODEL_PATH / MODEL_NAMEMODEL_SAVE_PATHtorch.save(obj = model_0.state_dict(), f = MODEL_SAVE_PATH)# 读取数据至新模型loaded_model_0 = LinearRegressionModel()loaded_model_0.state_dict()# 赋值参数loaded_model_0.load_state_dict(torch.load(f = MODEL_SAVE_PATH))","link":"/posts/dfb3c4cb/"},{"title":"井字棋AI_强化","text":"完善了井字棋AI—NanaGo的内部函数，使他更加智能。 AI内核函数使用了简单的穷举遍历计算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220def __computer_chess(self): \"\"\" 电脑下棋NanaGo \"\"\" if self.__game_status != GameStatus.PLAYING: return ########################################################### # 下一子后, 判断自己是否直接获胜 ########################################################### # 横向判断 for row in range(3): fork_count = 0 empty_col = -1 for col in range(3): if self.__chess_map[row][col] == ChessType.FORK: fork_count += 1 elif self.__chess_map[row][col] == ChessType.EMPTY: empty_col = col # 2个叉, 并且有一个空白, 则直接下到空白处 if fork_count == 2 and empty_col &gt;= 0: self.__chess_map[row][empty_col] = ChessType.FORK print(f\"电脑(横向进攻): ({row}, {empty_col}) &lt;- 叉\") return # 纵向判断 for col in range(3): fork_count = 0 empty_row = -1 for row in range(3): if self.__chess_map[row][col] == ChessType.FORK: fork_count += 1 elif self.__chess_map[row][col] == ChessType.EMPTY: empty_row = row # 2个叉, 并且有一个空白, 则直接下到空白处 if fork_count == 2 and empty_row &gt;= 0: self.__chess_map[empty_row][col] = ChessType.FORK print(f\"电脑(纵向进攻): ({empty_row}, {col}) &lt;- 叉\") return # 对角线判断(左上-右下) fork_count = 0 empty_row, empty_col = -1, -1 if self.__chess_map[0][0] == ChessType.FORK: fork_count += 1 elif self.__chess_map[0][0] == ChessType.EMPTY: empty_row, empty_col = 0, 0 if self.__chess_map[1][1] == ChessType.FORK: fork_count += 1 elif self.__chess_map[1][1] == ChessType.EMPTY: empty_row, empty_col = 1, 1 if self.__chess_map[2][2] == ChessType.FORK: fork_count += 1 elif self.__chess_map[2][2] == ChessType.EMPTY: empty_row, empty_col = 2, 2 # 2个叉, 并且有一个空白, 则直接下到空白处 if fork_count == 2 and empty_row &gt;= 0: self.__chess_map[empty_row][empty_col] = ChessType.FORK print(f\"电脑(对角线\\\\进攻): ({empty_row}, {empty_col}) &lt;- 叉\") return # 对角线判断(左下 - 右上) fork_count = 0 empty_row, empty_col = -1, -1 if self.__chess_map[2][0] == ChessType.FORK: fork_count += 1 elif self.__chess_map[2][0] == ChessType.EMPTY: empty_row, empty_col = 2, 0 if self.__chess_map[1][1] == ChessType.FORK: fork_count += 1 elif self.__chess_map[1][1] == ChessType.EMPTY: empty_row, empty_col = 1, 1 if self.__chess_map[0][2] == ChessType.FORK: fork_count += 1 elif self.__chess_map[0][2] == ChessType.EMPTY: empty_row, empty_col = 0, 2 # 2个叉, 并且有一个空白, 则直接下到空白处 if fork_count == 2 and empty_row &gt;= 0: self.__chess_map[empty_row][empty_col] = ChessType.FORK print(f\"电脑(对角线/进攻): ({empty_row}, {empty_col}) &lt;- 叉\") return ########################################################### # 如果对方下一子后, 能直接获胜, 则需要在对应位置堵住对方 ########################################################### # 横向判断 for row in range(3): circle_count = 0 empty_col = -1 for col in range(3): if self.__chess_map[row][col] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[row][col] == ChessType.EMPTY: empty_col = col # 2个圈, 并且有一个空白, 则直接下到空白处 if circle_count == 2 and empty_col &gt;= 0: self.__chess_map[row][empty_col] = ChessType.FORK print(f\"电脑(横向防守): ({row}, {empty_col}) &lt;- 叉\") return # 纵向判断 for col in range(3): circle_count = 0 empty_row = -1 for row in range(3): if self.__chess_map[row][col] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[row][col] == ChessType.EMPTY: empty_row = row # 2个圈, 并且有一个空白, 则直接下到空白处 if circle_count == 2 and empty_row &gt;= 0: self.__chess_map[empty_row][col] = ChessType.FORK print(f\"电脑(纵向防守): ({empty_row}, {col}) &lt;- 叉\") return # 对角线判断(左上-右下) circle_count = 0 empty_row, empty_col = -1, -1 if self.__chess_map[0][0] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[0][0] == ChessType.EMPTY: empty_row, empty_col = 0, 0 if self.__chess_map[1][1] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[1][1] == ChessType.EMPTY: empty_row, empty_col = 1, 1 if self.__chess_map[2][2] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[2][2] == ChessType.EMPTY: empty_row, empty_col = 2, 2 # 2个圈, 并且有一个空白, 则直接下到空白处 if circle_count == 2 and empty_row &gt;= 0 and empty_col &gt;= 0: self.__chess_map[empty_row][empty_col] = ChessType.FORK print(f\"电脑(对角线\\\\防守): ({empty_row}, {empty_col}) &lt;- 叉\") return # 对角线判断(左下 - 右上) circle_count = 0 empty_row, empty_col = -1, -1 if self.__chess_map[2][0] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[2][0] == ChessType.EMPTY: empty_row, empty_col = 2, 0 if self.__chess_map[1][1] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[1][1] == ChessType.EMPTY: empty_row, empty_col = 1, 1 if self.__chess_map[0][2] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[0][2] == ChessType.EMPTY: empty_row, empty_col = 0, 2 # 2个圈, 并且有一个空白, 则直接下到空白处 if circle_count == 2 and empty_row &gt;= 0 and empty_col &gt;= 0: self.__chess_map[empty_row][empty_col] = ChessType.FORK print(f\"电脑(对角线/防守): ({empty_row}, {empty_col}) &lt;- 叉\") return ########################################################### # 优先占角 ########################################################### angles = [(0, 0), (0, 2), (2, 0), (2, 2)] random.shuffle(angles) for angle in angles: row, col = angle[0], angle[1] if self.__chess_map[row][col] == ChessType.EMPTY: self.__chess_map[row][col] = ChessType.FORK print(f\"电脑(优先占角): ({row}, {col}) &lt;- 叉\") return ########################################################### # 次要占中心 ########################################################### if self.__chess_map[1][1] == ChessType.EMPTY: self.__chess_map[1][1] = ChessType.FORK print(f\"电脑(占中心): (1, 1) &lt;- 叉\") return ########################################################### # 其他情况, 在剩余空白处随机下一个叉 ########################################################### empty_count = 0 for row in range(3): for col in range(3): if self.__chess_map[row][col] == ChessType.EMPTY: empty_count += 1 if empty_count &lt;= 0: return new_fork_chess_pos = random.randrange(empty_count) empty_pos = 0 print(\"new_fork_chess_pos\", new_fork_chess_pos) print(\"empty_count\", empty_count) for row in range(3): is_pass = False for col in range(3): if self.__chess_map[row][col] == ChessType.EMPTY: if empty_pos != new_fork_chess_pos: empty_pos += 1 continue self.__chess_map[row][col] = ChessType.FORK print(f\"电脑(随机落子): ({row}, {col}) &lt;- 叉\") is_pass = True break if is_pass: break 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645import enumimport randomfrom typing import List, Tuple, Optionalimport pygameBG_COLOR = pygame.Color(\"#EEEEEE\") #背景BOARD_COLAR = pygame.Color(\"#E96666\") # 边框CIRCLE_CHESS_COLOR = pygame.Color(\"#3CA273\") # 画圈圈的棋子的颜色FORK_CHESS_COLOR = pygame.Color(\"#5570C2\") # 画叉的棋子的颜色WIN_LINE_COLOR = pygame.Color(\"#FFA801\") # 获胜划线CIRCLE_WIN_HINT_TEXT_COLOR = pygame.Color(\"#029999\") # 画圈获胜文本FORK_WIN_HINT_TEXT_COLOR = pygame.Color(\"#E94466\") # 画叉获胜文本TIE_HINT_TEXT_COLOR = pygame.Color(\"#FAC888\") # 平局文本RESTART_HINT_TEXT_COLOR = pygame.Color(\"#91CBBB\") #重新开始def main(): # 初试化 pygame.init() pygame.display.set_caption(\"井字棋AI_NanaGo\") screen = pygame.display.set_mode((500,500)) clock = pygame.time.Clock() scene = GameScene() while True: for event in pygame.event.get(): # 退出判断 if event.type == pygame.QUIT: pygame.quit() return # 处理鼠标的输入，传递到我的场景中进行处理 if event.type == pygame.MOUSEBUTTONDOWN: if event.dict[\"button\"] == pygame.BUTTON_LEFT: pos = event.dict[\"pos\"] #pos is a tuple scene.on_mouse_left_button_down(pos[0], pos[1]) elif event.type == pygame.MOUSEMOTION: #鼠标移动 pos = event.dict[\"pos\"] #pos is a tuple scene.on_mouse_motion(pos[0], pos[1]) #绘制场景 scene.draw(screen) #更新屏幕 pygame.display.flip() #限制帧率 clock.tick(30) class ChessType(enum.Enum): \"\"\" 棋子类型，画圈圈的是人类，画叉的是电脑AI \"\"\" EMPTY = 0 \"\"\"空位，没有被下子\"\"\" CIRCLE = 1 FORK = 2class GameStatus(enum.Enum): \"\"\" 游戏状态 \"\"\" PLAYING = 0 CIRCLE_WIN = 1 FORK_WIN = 2 TIE = 3 \"\"\"平局\"\"\"class GameScene: \"\"\" 游戏场景 \"\"\" __game_status: GameStatus = None __chess_map: List[List[ChessType]] = None __curr_mouse_down_pos: Optional[Tuple[int, int]] = None __curr_mouse_motion_pos: Optional[Tuple[int, int]] = None __win_pos_start: Optional[Tuple[int, int]] = None __win_pos_end: Optional[Tuple[int, int]] = None __circle_win_hint_text: pygame.Surface = None __fork_win_hint_text: pygame.Surface = None __tie_hint_text: pygame.Surface = None __restart_text: pygame.Surface = None def __init__(self): font = pygame.font.Font(pygame.font.get_default_font(), 25) self.__circle_win_hint_text = font.render(\"You Win\", True, CIRCLE_WIN_HINT_TEXT_COLOR) self.__fork_win_hint_text = font.render(\"NanaGo Win\", True, FORK_WIN_HINT_TEXT_COLOR) self.__tie_hint_text = font.render(\"Tie\", True, TIE_HINT_TEXT_COLOR) self.__restart_text = font.render(\"Click for a new game\", True, RESTART_HINT_TEXT_COLOR) self.__init() def __init(self): print(\"初始化ing\") self.__game_status = GameStatus.PLAYING self.__chess_map = [ [ChessType.EMPTY,ChessType.EMPTY,ChessType.EMPTY], [ChessType.EMPTY,ChessType.EMPTY,ChessType.EMPTY], [ChessType.EMPTY,ChessType.EMPTY,ChessType.EMPTY] ] self.__curr_mouse_down_pos = None self.__win_pos_start = None self.__win_pos_end = None if random.random() &gt; 0.5: print(\"电脑先手\") self.__computer_chess() self.__check_game_over() else: print(\"人类先手\") def __computer_chess(self): \"\"\" 电脑下棋 \"\"\" \"\"\" v1, 从左上角开始依次遍历，然后下到第一个empty的地方 \"\"\" # for c in range(3): # for r in range(3): # if self.__chess_map[r][c] == ChessType.EMPTY: # self.__chess_map[r][c] = ChessType.FORK # return \"\"\" v2, 穷举法遍历 \"\"\" if self.__game_status != GameStatus.PLAYING: return ########################################################### # 下一子后, 判断自己是否直接获胜 ########################################################### # 横向判断 for row in range(3): fork_count = 0 empty_col = -1 for col in range(3): if self.__chess_map[row][col] == ChessType.FORK: fork_count += 1 elif self.__chess_map[row][col] == ChessType.EMPTY: empty_col = col # 2个叉, 并且有一个空白, 则直接下到空白处 if fork_count == 2 and empty_col &gt;= 0: self.__chess_map[row][empty_col] = ChessType.FORK print(f\"电脑(横向进攻): ({row}, {empty_col}) &lt;- 叉\") return # 纵向判断 for col in range(3): fork_count = 0 empty_row = -1 for row in range(3): if self.__chess_map[row][col] == ChessType.FORK: fork_count += 1 elif self.__chess_map[row][col] == ChessType.EMPTY: empty_row = row # 2个叉, 并且有一个空白, 则直接下到空白处 if fork_count == 2 and empty_row &gt;= 0: self.__chess_map[empty_row][col] = ChessType.FORK print(f\"电脑(纵向进攻): ({empty_row}, {col}) &lt;- 叉\") return # 对角线判断(左上-右下) fork_count = 0 empty_row, empty_col = -1, -1 if self.__chess_map[0][0] == ChessType.FORK: fork_count += 1 elif self.__chess_map[0][0] == ChessType.EMPTY: empty_row, empty_col = 0, 0 if self.__chess_map[1][1] == ChessType.FORK: fork_count += 1 elif self.__chess_map[1][1] == ChessType.EMPTY: empty_row, empty_col = 1, 1 if self.__chess_map[2][2] == ChessType.FORK: fork_count += 1 elif self.__chess_map[2][2] == ChessType.EMPTY: empty_row, empty_col = 2, 2 # 2个叉, 并且有一个空白, 则直接下到空白处 if fork_count == 2 and empty_row &gt;= 0: self.__chess_map[empty_row][empty_col] = ChessType.FORK print(f\"电脑(对角线\\\\进攻): ({empty_row}, {empty_col}) &lt;- 叉\") return # 对角线判断(左下 - 右上) fork_count = 0 empty_row, empty_col = -1, -1 if self.__chess_map[2][0] == ChessType.FORK: fork_count += 1 elif self.__chess_map[2][0] == ChessType.EMPTY: empty_row, empty_col = 2, 0 if self.__chess_map[1][1] == ChessType.FORK: fork_count += 1 elif self.__chess_map[1][1] == ChessType.EMPTY: empty_row, empty_col = 1, 1 if self.__chess_map[0][2] == ChessType.FORK: fork_count += 1 elif self.__chess_map[0][2] == ChessType.EMPTY: empty_row, empty_col = 0, 2 # 2个叉, 并且有一个空白, 则直接下到空白处 if fork_count == 2 and empty_row &gt;= 0: self.__chess_map[empty_row][empty_col] = ChessType.FORK print(f\"电脑(对角线/进攻): ({empty_row}, {empty_col}) &lt;- 叉\") return ########################################################### # 如果对方下一子后, 能直接获胜, 则需要在对应位置堵住对方 ########################################################### # 横向判断 for row in range(3): circle_count = 0 empty_col = -1 for col in range(3): if self.__chess_map[row][col] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[row][col] == ChessType.EMPTY: empty_col = col # 2个圈, 并且有一个空白, 则直接下到空白处 if circle_count == 2 and empty_col &gt;= 0: self.__chess_map[row][empty_col] = ChessType.FORK print(f\"电脑(横向防守): ({row}, {empty_col}) &lt;- 叉\") return # 纵向判断 for col in range(3): circle_count = 0 empty_row = -1 for row in range(3): if self.__chess_map[row][col] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[row][col] == ChessType.EMPTY: empty_row = row # 2个圈, 并且有一个空白, 则直接下到空白处 if circle_count == 2 and empty_row &gt;= 0: self.__chess_map[empty_row][col] = ChessType.FORK print(f\"电脑(纵向防守): ({empty_row}, {col}) &lt;- 叉\") return # 对角线判断(左上-右下) circle_count = 0 empty_row, empty_col = -1, -1 if self.__chess_map[0][0] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[0][0] == ChessType.EMPTY: empty_row, empty_col = 0, 0 if self.__chess_map[1][1] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[1][1] == ChessType.EMPTY: empty_row, empty_col = 1, 1 if self.__chess_map[2][2] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[2][2] == ChessType.EMPTY: empty_row, empty_col = 2, 2 # 2个圈, 并且有一个空白, 则直接下到空白处 if circle_count == 2 and empty_row &gt;= 0 and empty_col &gt;= 0: self.__chess_map[empty_row][empty_col] = ChessType.FORK print(f\"电脑(对角线\\\\防守): ({empty_row}, {empty_col}) &lt;- 叉\") return # 对角线判断(左下 - 右上) circle_count = 0 empty_row, empty_col = -1, -1 if self.__chess_map[2][0] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[2][0] == ChessType.EMPTY: empty_row, empty_col = 2, 0 if self.__chess_map[1][1] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[1][1] == ChessType.EMPTY: empty_row, empty_col = 1, 1 if self.__chess_map[0][2] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[0][2] == ChessType.EMPTY: empty_row, empty_col = 0, 2 # 2个圈, 并且有一个空白, 则直接下到空白处 if circle_count == 2 and empty_row &gt;= 0 and empty_col &gt;= 0: self.__chess_map[empty_row][empty_col] = ChessType.FORK print(f\"电脑(对角线/防守): ({empty_row}, {empty_col}) &lt;- 叉\") return ########################################################### # 优先占角 ########################################################### angles = [(0, 0), (0, 2), (2, 0), (2, 2)] random.shuffle(angles) for angle in angles: row, col = angle[0], angle[1] if self.__chess_map[row][col] == ChessType.EMPTY: self.__chess_map[row][col] = ChessType.FORK print(f\"电脑(优先占角): ({row}, {col}) &lt;- 叉\") return ########################################################### # 次要占中心 ########################################################### if self.__chess_map[1][1] == ChessType.EMPTY: self.__chess_map[1][1] = ChessType.FORK print(f\"电脑(占中心): (1, 1) &lt;- 叉\") return ########################################################### # 其他情况, 在剩余空白处随机下一个叉 ########################################################### empty_count = 0 for row in range(3): for col in range(3): if self.__chess_map[row][col] == ChessType.EMPTY: empty_count += 1 if empty_count &lt;= 0: return new_fork_chess_pos = random.randrange(empty_count) empty_pos = 0 print(\"new_fork_chess_pos\", new_fork_chess_pos) print(\"empty_count\", empty_count) for row in range(3): is_pass = False for col in range(3): if self.__chess_map[row][col] == ChessType.EMPTY: if empty_pos != new_fork_chess_pos: empty_pos += 1 continue self.__chess_map[row][col] = ChessType.FORK print(f\"电脑(随机落子): ({row}, {col}) &lt;- 叉\") is_pass = True break if is_pass: break def __check_game_over(self): for c in range(3): circle_count = 0 fork_count = 0 for r in range(3): if self.__chess_map[r][c] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[r][c] == ChessType.FORK: fork_count += 1 if circle_count == 3: self.__game_status = GameStatus.CIRCLE_WIN self.__win_pos_start = (0, c) self.__win_pos_end = (2, c) print(\"人类获胜\") break if fork_count == 3: self.__game_status = GameStatus.FORK_WIN self.__win_pos_start = (0, c) self.__win_pos_end = (2, c) print(\"电脑获胜\") break if self.__game_status != GameStatus.PLAYING: return for r in range(3): circle_count = 0 fork_count = 0 for c in range(3): if self.__chess_map[r][c] == ChessType.CIRCLE: circle_count += 1 elif self.__chess_map[r][c] == ChessType.FORK: fork_count += 1 if circle_count == 3: self.__game_status = GameStatus.CIRCLE_WIN self.__win_pos_start = (r, 0) self.__win_pos_end = (r, 2) print(\"人类获胜\") break if fork_count == 3: self.__game_status = GameStatus.FORK_WIN self.__win_pos_start = (r, 0) self.__win_pos_end = (r, 2) print(\"电脑获胜\") break if self.__game_status != GameStatus.PLAYING: return if self.__chess_map[0][0] == ChessType.CIRCLE and self.__chess_map[1][1] == ChessType.CIRCLE and self.__chess_map[2][2] == ChessType.CIRCLE: self.__game_status = GameStatus.CIRCLE_WIN self.__win_pos_start = (0,0) self.__win_pos_end = (2,2) elif self.__chess_map[0][0] == ChessType.FORK and self.__chess_map[1][1] == ChessType.FORK and self.__chess_map[2][2] == ChessType.FORK: self.__game_status = GameStatus.FORK_WIN self.__win_pos_start = (0,0) self.__win_pos_end = (2,2) elif self.__chess_map[2][0] == ChessType.CIRCLE and self.__chess_map[1][1] == ChessType.CIRCLE and self.__chess_map[0][2] == ChessType.CIRCLE: self.__game_status = GameStatus.CIRCLE_WIN self.__win_pos_start = (2,0) self.__win_pos_end = (0, 2) elif self.__chess_map[2][0] == ChessType.FORK and self.__chess_map[1][1] == ChessType.FORK and self.__chess_map[0][2] == ChessType.FORK: self.__game_status = GameStatus.FORK_WIN self.__win_pos_start = (2,0) self.__win_pos_end = (0,2) if self.__game_status != GameStatus.PLAYING: return has_empty = False for r in range(3): for c in range(3): if self.__chess_map[r][c] == ChessType.EMPTY: has_empty = True break if has_empty == True: break if not has_empty: self.__game_status == GameStatus.TIE def __get_mouse_on_board_pos(self, board_pos: Tuple[int, int], cell_size: int, mouse_pos:Tuple[int, int]) -&gt;Tuple[int, int]: \"\"\" 获取当前鼠标位置在棋盘中的行列位置(index)(eg(0,0)(0,1)(0,2),...(2,0)(2,1)(2,2))，鼠标没有在棋盘中返回(-1,-1) \"\"\" assert self #为了防止报错或者warning board_x, board_y = board_pos[0], board_pos[1] mouse_x, mouse_y = mouse_pos[0], mouse_pos[1] x, y = mouse_x - board_x, mouse_y - board_y #用相对距离 if x &lt; 0 or y &lt; 0 or x &gt;= cell_size * 3 or y &gt;= cell_size * 3: return -1, -1 # 竖直方向表示行，水平方向表示列 return y // cell_size, x // cell_size def on_mouse_left_button_down(self, pos_x: int, pos_y: int): \"\"\" 鼠标左键按下 \"\"\" self.__curr_mouse_down_pos = (pos_x, pos_y) def on_mouse_motion(self, pos_x:int, pos_y:int): self.__curr_mouse_motion_pos = (pos_x, pos_y) def draw(self, screen: pygame.Surface): #填充背景 screen.fill(BG_COLOR) #绘制棋盘 board_cell_size = 100 board_x = round(screen.get_width() / 2 - (3 * board_cell_size) / 2) board_y = round(screen.get_height() / 2 - (3 * board_cell_size) / 2) self.__draw_board(screen, (board_x,board_y),board_cell_size,3) # 如果处于游戏中，判断鼠标（人类）是否有落子 if self.__game_status == GameStatus.PLAYING and self.__curr_mouse_down_pos: row, col = self.__get_mouse_on_board_pos((board_x, board_y), board_cell_size, self.__curr_mouse_down_pos) # 人类落子 self.__chess_map[row][col] = ChessType.CIRCLE print(f\"人类(点击落子):({row}, {col}) &lt;- 圈\") self.__check_game_over() if self.__game_status == GameStatus.PLAYING: self.__computer_chess() self.__check_game_over() self.__curr_mouse_down_pos = None if self.__game_status != GameStatus.PLAYING and self.__curr_mouse_down_pos: self.__init() self.__draw_chess(screen, (board_x,board_y),board_cell_size,20,5) self.__draw_win_line(screen, (board_x,board_y),board_cell_size,3) self.__draw_hint_text(screen, (board_x,board_y),board_cell_size) def __draw_board(self, screen:pygame.Surface, board_pos:Tuple[int, int], cell_size:int, line_width:int): \"\"\" 绘制棋盘 \"\"\" assert self x, y = board_pos[0], board_pos[1] #横线 x1 = x x2 = x + 3 * cell_size y1 = y + cell_size y2 = y + 2 * cell_size pygame.draw.line(screen,BOARD_COLAR,(x1,y1),(x2, y1),line_width) pygame.draw.line(screen,BOARD_COLAR,(x1,y2),(x2, y2),line_width) y1 = y y2 = y + 3 * cell_size x1 = x + cell_size x2 = x + 2 * cell_size pygame.draw.line(screen,BOARD_COLAR,(x1,y1),(x1, y2),line_width) pygame.draw.line(screen,BOARD_COLAR,(x2,y1),(x2, y2),line_width) def __draw_chess(self, screen:pygame.Surface, board_pos:Tuple[int,int], board_cell_size:int, padding:int, border_width:int): \"\"\" 绘制棋子 \"\"\" board_x, board_y = board_pos[0], board_pos[1] for r in range(len(self.__chess_map)): row = self.__chess_map[r] for c in range(len(row)): chess = row[c] if chess == ChessType.CIRCLE: self.__draw_circle_chess(screen, (board_x + c * board_cell_size, board_y + r * board_cell_size), board_cell_size, padding, border_width) elif chess == ChessType.FORK: self.__draw_fork_chess(screen, (board_x + c * board_cell_size, board_y + r * board_cell_size), board_cell_size, padding, border_width) def __draw_circle_chess(self, screen:pygame.Surface, chess_pos:Tuple[int,int], board_cell_size:int, padding:int, border_width:int): \"\"\" 绘制圆棋子 \"\"\" assert self chess_x, chess_y = chess_pos[0], chess_pos[1] center = round(chess_x + board_cell_size / 2), round(chess_y + board_cell_size / 2) radius = round(board_cell_size / 2 - padding) pygame.draw.circle(screen, CIRCLE_CHESS_COLOR, center, radius, border_width) def __draw_fork_chess(self, screen:pygame.Surface, chess_pos:Tuple[int,int], board_cell_size:int, padding:int, border_width:int): \"\"\" 绘制叉棋子 \"\"\" assert self chess_x, chess_y = chess_pos[0], chess_pos[1] pygame.draw.line(screen, FORK_CHESS_COLOR, (chess_x + padding, chess_y + padding), (chess_x + board_cell_size - padding, chess_y + board_cell_size - padding ), border_width) pygame.draw.line(screen, FORK_CHESS_COLOR, (chess_x + board_cell_size - padding, chess_y + padding), (chess_x + padding, chess_y + board_cell_size - padding ), border_width) def __draw_win_line(self, screen:pygame.Surface, board_pos:Tuple[int,int], cell_size:int, line_width:int): \"\"\" 绘制获胜曲线 \"\"\" if (not self.__win_pos_start) or (not self.__win_pos_end): return board_x, board_y = board_pos[0], board_pos[1] pos_start_row, pos_start_col = self.__win_pos_start[0], self.__win_pos_start[1] pos_end_row, pos_end_col = self.__win_pos_end[0], self.__win_pos_end[1] half_cell_size = round(cell_size / 2) start = (board_x + pos_start_col * cell_size + half_cell_size, board_y + pos_start_row * cell_size + half_cell_size) end = (board_x + pos_end_col * cell_size + half_cell_size, board_y + pos_end_row * cell_size + half_cell_size) pygame.draw.line(screen, WIN_LINE_COLOR, start, end, line_width) def __draw_hint_text(self, screen:pygame.Surface, board_pos:Tuple[int,int], cell_size:int, ): board_y = board_pos[1] if self.__game_status == GameStatus.CIRCLE_WIN: screen.blit(self.__circle_win_hint_text, (screen.get_width() / 2 - self.__circle_win_hint_text.get_width() / 2, board_y / 2 - self.__circle_win_hint_text.get_height() / 2)) elif self.__game_status == GameStatus.FORK_WIN: screen.blit(self.__fork_win_hint_text, (screen.get_width() / 2 - self.__fork_win_hint_text.get_width() / 2, board_y / 2 - self.__fork_win_hint_text.get_height() / 2)) elif self.__game_status == GameStatus.TIE: screen.blit(self.__tie_hint_text, (screen.get_width() / 2 - self.__tie_hint_text.get_width() / 2, board_y / 2 - self.__tie_hint_text.get_height() / 2)) if self.__game_status != GameStatus.PLAYING: #重新开始的提示 screen.blit(self.__restart_text, (screen.get_width() / 2 - self.__restart_text.get_width() / 2, (screen.get_height() + (board_y + cell_size * 3)) / 2 - self.__restart_text.get_height() / 2))if __name__ == \"__main__\": print(\"pygame is called\") main() 效果图总体上来讲，NanaGo还是很强大的。","link":"/posts/c079033b/"},{"title":"博客图片插入功能","text":"hexo-abbrlink与hexo-asset-images插件冲突的解决办法 一、需求描述目前，图片本地插入的三种主流实现方法，分别为：img路径方法插入图片、 ！[]()方式插入图片、通过{%%}插入本地图片其中，！[]()方式插入图片是markdown的插入图片语句，语法为： 1![图片加载失败的描述](图片链接) 这种格式，能够很好满足我使用Typora，实时预览的需求。通常情况下，使用如下插件便可以很方便的完成相对路径的地址转换（实现途径自行查询）： 1npm install hexo-asset-image --save 但是，由于笔者使用了hexo-abbrlink插件，改变了github中图片路径，导致github仓库中相对路径，无法查询到对应图片。 二、解决办法首先，下载cheerio插件: 1npm install cheerio 然后，在原有hexo-asset-images插件基础上修改，实现相对路径的变更 hexo-asset-images/index.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) { return str.split(m, i).join(m).length;}hexo.extend.filter.register('after_post_render', function(data) { var config = hexo.config; if (config.post_asset_folder) { var link = data.permalink; var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of \"about\" page is like \".../about/index.html\". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for (var i = 0; i &lt; toprocess.length; i++) { var key = toprocess[i]; var $ = cheerio.load(data[key], { ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false }); $('img').each(function() { // For windows style path, we replace '\\' to '/'. var src = $(this).attr('src').replace('\\\\', '/'); if (!/http[s]*.*|\\/\\/.*/.test(src)) { // For \"about\" page, the first part of \"src\" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem) { return elem != ''; }); var srcArray = src.split('/').filter(function(elem) { return elem != ''; }); if (linkArray[linkArray.length - 1] == srcArray[0]) srcArray.shift(); src = srcArray.join('/'); var root = config.root &amp;&amp; config.root.endsWith('/') ? config.root : '/' var abbrlink = data.abbrlink; if (abbrlink) { if (src.indexOf(abbrlink) &gt; -1) { // 使用 hexo asset_img：{% asset_img 20190522103754.jpg %} // root = / // link = posts/ // abbrlink = d6d2f549 // src = d6d2f549/20190522103754.jpg $(this).attr('src', root + link + src); } else { // 使用 markdown 标准语法：![图片](title/20190522103754.jpg) // 或者 typora 其中一个用法：![图片](20190522103754.jpg) // root = / // link = posts/ // abbrlink = d6d2f549 // src = title/20190522103754.jpg // 或者 src = 20190522103754.jpg if (src.indexOf('/') &gt; -1) { src = src.substring(src.lastIndexOf('/') + 1); } $(this).attr('src', root + link + src); } } else { $(this).attr('src', root + link + src); } } }); data[key] = $.html(); } }}); hexo-asset-images/package.json123456789101112131415161718192021{ \"name\": \"hexo-asset-image\", \"version\": \"0.1.0\", \"description\": \"Give asset image in hexo a absolutely path automatically\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"keywords\": [ \"hexo\", \"iamge\", \"asset\", \"path\" ], \"author\": \"codefalling\", \"license\": \"MIT\", \"dependencies\": { \"cheerio\": \"^0.19.0\" }} 注意 在typora中进行图片插入时，图片名中间不能有空格，否则无法完成相对路径的自动转换。 typora图片插入的相对路径，不要忘记设置。 使用该插件后，只能使用npm new \"XXX\"方式，生成.md文档。(自己向_post文件中拖拽和新建对应图片文件夹，是无效滴) 不同博客的github中的文件路径可能有所差别，可以在github相应博文.html页面中进行比对(如下)，从而对index.js和package.json中相对路径转换格式做出调整。","link":"/posts/beac9b05/"},{"title":"评论区食用说明","text":"评论区需要搭外网vpn才能查看和发表评论。 本博客的评论功能，由Vercel云函数部署实现。 这很有可能是导致在中国大陆访问速度较慢甚至无法访问的根本原因。 后续会进行优化，或者重新部署hh（挖坑）","link":"/posts/1a827395/"}],"tags":[{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"不带头结点","slug":"不带头结点","link":"/tags/%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9/"},{"name":"按值删除","slug":"按值删除","link":"/tags/%E6%8C%89%E5%80%BC%E5%88%A0%E9%99%A4/"},{"name":"单链表","slug":"单链表","link":"/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"带头结点","slug":"带头结点","link":"/tags/%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9/"},{"name":"逆序","slug":"逆序","link":"/tags/%E9%80%86%E5%BA%8F/"},{"name":"空间复杂度低","slug":"空间复杂度低","link":"/tags/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BD%8E/"},{"name":"最小值","slug":"最小值","link":"/tags/%E6%9C%80%E5%B0%8F%E5%80%BC/"},{"name":"高效算法","slug":"高效算法","link":"/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/"},{"name":"元素递增","slug":"元素递增","link":"/tags/%E5%85%83%E7%B4%A0%E9%80%92%E5%A2%9E/"},{"name":"共享栈","slug":"共享栈","link":"/tags/%E5%85%B1%E4%BA%AB%E6%A0%88/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"gvim","slug":"gvim","link":"/tags/gvim/"},{"name":"配置相关","slug":"配置相关","link":"/tags/%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3/"},{"name":"分类任务","slug":"分类任务","link":"/tags/%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/"},{"name":"机器学习","slug":"机器学习","link":"/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"Pytorch","slug":"Pytorch","link":"/tags/Pytorch/"},{"name":"Spawn_failed","slug":"Spawn-failed","link":"/tags/Spawn-failed/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"日志","slug":"日志","link":"/tags/%E6%97%A5%E5%BF%97/"},{"name":"判断对称性","slug":"判断对称性","link":"/tags/%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E6%80%A7/"},{"name":"conda","slug":"conda","link":"/tags/conda/"},{"name":"报错","slug":"报错","link":"/tags/%E6%8A%A5%E9%94%99/"},{"name":"查找","slug":"查找","link":"/tags/%E6%9F%A5%E6%89%BE/"},{"name":"项目","slug":"项目","link":"/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"小游戏","slug":"小游戏","link":"/tags/%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"AI","slug":"AI","link":"/tags/AI/"},{"name":"线性回归","slug":"线性回归","link":"/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"},{"name":"插入图片功能","slug":"插入图片功能","link":"/tags/%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%8A%9F%E8%83%BD/"},{"name":"twikoo","slug":"twikoo","link":"/tags/twikoo/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"单链表","slug":"算法/单链表","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"算法/栈","link":"/categories/%E7%AE%97%E6%B3%95/%E6%A0%88/"},{"name":"GVim","slug":"GVim","link":"/categories/GVim/"},{"name":"机器学习","slug":"机器学习","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"栈","slug":"算法/单链表/栈","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E9%93%BE%E8%A1%A8/%E6%A0%88/"},{"name":"环境配置","slug":"环境配置","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"二分查找","slug":"算法/二分查找","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"项目","slug":"项目","link":"/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"Pytorch,多分类","slug":"机器学习/Pytorch-多分类","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Pytorch-%E5%A4%9A%E5%88%86%E7%B1%BB/"},{"name":"Pytorch","slug":"机器学习/Pytorch","link":"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Pytorch/"},{"name":"报错","slug":"hexo/报错","link":"/categories/hexo/%E6%8A%A5%E9%94%99/"},{"name":"icarus","slug":"hexo/icarus","link":"/categories/hexo/icarus/"},{"name":"conda","slug":"环境配置/conda","link":"/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/conda/"},{"name":"小游戏","slug":"项目/小游戏","link":"/categories/%E9%A1%B9%E7%9B%AE/%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"name":"twikoo","slug":"hexo/twikoo","link":"/categories/hexo/twikoo/"}],"pages":[{"title":"About me","text":"这里是Nanachilil的旧仓库。用于记录和分享个人学习历程。偶尔也会发布一些兴趣爱好相关的博文。但因为自己表达能力很差，更多只是写给自己看的，如果发现看不懂应该很正常 😰，不懂之处和可以改进的地方欢迎留言 🙏 兴趣爱好：健身、悬疑恐怖故事、后朋克、推理小说 本站文章如无特别声明，均为原创，采用 知识共享署名 4.0 国际许可协议 进行许可，转载请注明来源。 本站采用了 Hexo 静态博客框架，主题为 Icarus。有使用上的疑问可在 Issue 中提问，也可在博客中留言。 本站使用 不蒜子 和 Google Analytics 统计访客数据，包括但不限于您的 IP 地址、地理位置、访问页面等，继续浏览代表您接受我们收集此类信息。如您不接受，可选择禁用本站 Javascript 权限（例：选择地址栏左边的小锁 - 站点权限 - Javascript - 阻止），这不会影响您正常浏览站内博客文章，但会影响搜索、评论等功能。","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"留言板","text":"留下足迹吧！ 由于本网站尚未备案，需要挂梯子才能评论。","link":"/guestbook/index.html"}]}