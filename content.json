{"posts":[{"title":"设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点 -001","text":"设计一个递归算法，删除不带头结点的单链表L中所有值为x的结点 总结​ 由于L为引用，是直接对原链表进行操作，所以不会断链。 ​ 参数引用是L-&gt;next,自我调用函数执行完后，虽然p所指结点被删除了，但是返回的依然是L-&gt;next。返回后，整个表是连续的。外层函数并不知道，内层调用时，L移动了位置。 代码123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;void Del_X_3(LinkList &amp;L,ElemType x){ LNode *p; //p指向待删除结点 if(L==NULL) return; if(L-&gt;data==x){ p=L; L=L-&gt;next; delete p; Del_X_3(L,x); } else //若L所指结点值不为x Del_X_3(L-&gt;next,x);}","link":"/posts/f8ef9f43/"},{"title":"带头结点的单链表L，删除所有值为x的结点，并释放空间，假设x唯一 -002","text":"带头结点的单链表L，删除所有值为x的结点，并释放空间，假设x唯一 总结删除结点时，使用first，second两个指针来遍历删除 代码1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;LinkList Del_X(LinkList &amp;L,int x){ LNode *first,*second; //first，second两个指针一前一后，遍历整个链表，并实现删除时连接 second=L; first=L-&gt;next; while(first!=NULL){ if(first-&gt;data==x){ second-&gt;next=first-&gt;next; delete first; first=second-&gt;next; }else{ first=first-&gt;next; second=second-&gt;next; } } return L;}","link":"/posts/68c06b74/"},{"title":"带头结点的单链表L，删除一个最小结点的高效算法（假设最小结点是唯一的） -004","text":"带头结点的单链表L，删除一个最小结点的高效算法（假设最小结点是唯一的） 总结​ 遍历指针，使用两个first，second（使用两个分别定位p，pre） ​ 最小值删除指针，使用两个p，pre 代码123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;void Del_min(LinkList &amp;L){ LNode *p=L-&gt;next,*pre=L; //p指向最小的结点.pre指向最小结点的前驱 LNode *first=p,*second=L; //first second 用于遍历单链表 while(p!=NULL){ if(p-&gt;data&lt;first-&gt;data){ first=p; second=pre; } second=first; first=first-&gt;next; } pre-&gt;next=p-&gt;next; delete p;}","link":"/posts/c9cd15b6/"},{"title":"带头结点的单链表L，设计一个算法使其元素递增 -006","text":"带头结点的单链表L，设计一个算法使其元素递增 总结​ 先构成只含一个数据结点的有序单链表，然后以此扫描单链表中剩下的结点p（直至p==NULL为止），在有序表中通过比较查找插入P的前驱结点pre，然后将p插入到pre之后。 代码1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;void Sort(LinkList &amp;L){ LNode *p=L-&gt;next,*pre; //p，pre分别作为两个链表的工作指针 LNode *r=p-&gt;next; //r为p的后继结点，保证不断链 p-&gt;next=NULL; //构造只含有一个数据结点的有序表 p=r; //使得p作为单链表的工作指针 while(p!=NULL){ r=p-&gt;next; //将r后移防止断链 pre=L; //每次循环，保证pre指向头结点，方便从头开始比较大小 while(pre-&gt;next!=NULL&amp;&amp;pre-&gt;next-&gt;data&lt;p-&gt;data){ //比较大小，直到满足，才在pre后面插入p结点 pre=pre-&gt;next; } p-&gt;next=pre-&gt;next; //插入的通用算法 pre-&gt;next=p; p=r; }}","link":"/posts/1f97bd59/"},{"title":"L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值 -003","text":"L为带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值 总结使用了栈的思想，逆序输出。所以用到了递归，间接使用栈 代码1234567891011121314151617#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;void R_print(LinkList &amp;L){ if(L-&gt;next!=NULL) R_print(L-&gt;next); if(L!=NULL) cout&lt;&lt;L-&gt;data&lt;&lt;endl;}void R_Ignore_Head(LinkList L){ if(L-&gt;next!=NULL) R_print(L-&gt;next);}","link":"/posts/3e29fe4e/"},{"title":"设有两个栈s1、s2都采用顺序栈方式，并共享一个存储区[0,  ,maxsize-1],为了尽量利用空间，减少溢出的可能，可采用栈顶相向，迎面增长的存储方式。试设计s1、s2有关入栈和出栈的操作方式 -008","text":"设有两个栈s1、s2都采用顺序栈方式，并共享一个存储区[0, ,maxsize-1],为了尽量利用空间，减少溢出的可能，可采用栈顶相向，迎面增长的存储方式。试设计s1、s2有关入栈和出栈的操作方式 总结算法思路​ 1、共享栈的定义 ​ 2、共享栈两个指针在入栈、出栈时的操作 代码注意点​ 1、共享栈的定义：数组空间、数组存储的两个栈顶指针 ​ 2、exit(0)和return的区别，exit(0)是直接终止进程，return是返回函数调用。 ​ 3、return 0：第一个含义一般用在主函数结束时，按照程序开发的一般惯例，表示成功完成本函数。第二个含义表示假，一般用于bool函数返回值。在C++中也可以直接用int，返回值为0时为假。宏定义ERROR 与FLASE一般为0。 ​ return 1: 与return 0 的第二个含义相对应，表示真，正确。宏定义TRUE，OK一般为1。 ​ return -1: 与return 0 的第一个含义相对应，表示返回一个代数值，一般用在子函数结尾。按照程序开发的一般惯例，表示该函数失败，在数据结构中，一般指**数据溢出(栈只会出现上溢)**，宏定义OVERFLOW 一般为-1。 ​ 4、switch每一个case后面都要有break 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#define maxsize 100#define ElemType int //定义ElemType为int类型using namespace std;typedef struct{ ElemType stack[maxsize]; int top[2]; //top为两个栈顶指针}stk;stk s; //s为全局变量//入栈操作int push(int i,ElemType x){ //i为栈号，i=0表示左边的s1栈，i=2表示右边的s2栈，x为入栈元素 if(i&lt;0||i&gt;1){ cout&lt;&lt;&quot;输入错误&quot;&lt;&lt;endl; exit(0); //exit(0)终止程序 } if(s.top[1]-s.top[0]==1){ cout&lt;&lt;&quot;已满&quot;&lt;&lt;endl; return 0; } switch(i){ case 0: s.stack[++s.top[0]]=x; return 1;break; case 1: s.stack[--s.top[1]]=x; return 1;break; }}//出栈ElemType pop(int i){ //i表示栈号 if(i&lt;0||i&gt;1){ cout&lt;&lt;&quot;栈号错误&quot;&lt;&lt;endl; exit(0); } switch(i){ case 0: if(s.top[0]==-1){ cout&lt;&lt;&quot;栈空&quot;&lt;&lt;endl; return -1; }else{ return s.stack[s.top[0]--]; } break; case 1: if(s.top[1]==maxsize){ cout&lt;&lt;&quot;栈空&quot;&lt;&lt;endl; return -1; }else{ return s.stack[s.top[1]--]; break; } }//switch}","link":"/posts/8d6133f4/"},{"title":"设单链表的表头指针为L，结点由data，next构成，设计算法判断该链表的全部n个字符是否中心对称。如xyx、xyyx -007","text":"设单链表的表头指针为L，结点由data，next构成，设计算法判断该链表的全部n个字符是否中心对称。如xyx、xyyx 总结算法思想：​ 使用栈来判断链表中的数据是否对称。先让前一半元素依次进栈。在处理链表的后一半元素时，当访问到链表的一个元素后，就从链表中弹出一个元素。按循环后数组下标来判断，是否对称 代码编写注意点：​ 1、数组下标从0开始，前一半元素下标是从0 &lt;= i &lt; n/2 ​ 2、判断元素个数为奇数 n%2==1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//设单链表的表头指针为L，结点由data，next构成，设计算法判断该链表的全部n个字符是否中心对称。如xyx、xyyx#include &lt;iostream&gt;using namespace std;typedef struct LNode { char data; struct LNode* next;}LNode, * LinkList;//参考答案int dc(LinkList L,int n){ int i; char s[n/2]; //s为字符栈 LNode *p=L-&gt;next; //p为工作指针，指向待处理的当前元素 for(i=0;i&lt;n/2;i++){ //链表前一半元素进栈，注意由于是数组，下标从零开始。所以i&lt;n/2 s[i]=p-&gt;data; p=p-&gt;next; } i--; //恢复最后的i值 if(n%2==1) //元素个数为奇数，移过中心点 p=p-&gt;next; while(p!=NULL&amp;&amp;s[i]==p-&gt;data){ i--; p=p-&gt;next; } if(i==-1) return 1; //对称 else return 0; //不对称}//自己写的代码bool dc(LinkList L, int n) { char* a = new char[n]; int i = 0, j = n - 1; //i,j 作为数组两端的工作指针 LNode* p = L-&gt;next; //作为遍历单链表的工作指针 int k=0; //字符转移 while (p != NULL) { a[k] = p-&gt;data; p = p-&gt;next; k++; } while (j - i &gt; 0) { if (a[i] == a[j]) { i++; j--; } else { cout &lt;&lt; &quot;错误&quot;; return false; } } delete[] a; return true;}int main() { LinkList L; L = new LNode; L-&gt;next = NULL; int n = 3; LNode* a, * b, * c; a = new LNode; b = new LNode; c = new LNode; a-&gt;data = 'x'; b-&gt;data = 'y'; c-&gt;data = 'y'; L-&gt;next=a; a-&gt;next=b; b-&gt;next=c; c-&gt;next = NULL; cout &lt;&lt; dc(L, n) &lt;&lt; endl; delete L; delete a; delete b; delete c; system(&quot;pause&quot;); return 0;}","link":"/posts/521b9f65/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/posts/16107/"},{"title":"带头结点代码，单链表逆置，辅助空间为O(1) -005","text":"带头结点代码，单链表逆置，辅助空间为O(1) 总结将头结点和之后结点断开，头插法插入。断开后，无头结点的链表，需要p，r两个指针（p为工作指针，r=p-&gt;next防止断链） 代码1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;typedef struct LNode{ ElemType data; struct LNode *next;}LNode,*LinkList;LinkList Reverse_l(LinkList &amp;L){ LNode *p,*r; //p为工作指针，r作为后继指针防止断链 p=L-&gt;next; L-&gt;next=NULL; while(p!=NULL){ r=p-&gt;next; p-&gt;next=L-&gt;next; L-&gt;next=p; p=r; } return L;}","link":"/posts/b6fb7676/"},{"title":"博客更新日志（1）","text":"本文章以日志形式记录icarus主题的更新内容。 2023/7/8尝试实现页面放大功能（完成）页面放大icarus/source/css/plus.styl # 没有就新建一个文件icarus/source/css/plus.styl >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213screen-tablet = 769pxscreen-desktop = 1088pxscreen-widescreen = 1280pxscreen-fullhd = 1472pxscreen-onek = 1700pxprimary-color = #fafafaprimary-color-hover = #71a1e0primary-color-active = #4382d6primary-color-light = rgba(93, 147, 219, 0.8)link-color = rgb(68,155,255)@media screen and (min-width: screen-onek) .container max-width: 1600px width: 1600px .column.is-3-widescreen width: 22% .column.is-6-widescreen width: 56%// Background imagebody background-color: transparentbody:before content: '' position: fixed z-index: -1 top: 0 right: 0 bottom: 0 left: 0 opacity: 0.01 transition: opacity 1s background: url(&quot;https://api.btstu.cn/sjbz/?lx=dongman&amp;format=images&amp;method=pc&quot;) center 0 no-repeat background-size: cover @media screen and (max-width: screen-tablet - 1) background-image: url(&quot;https://api.btstu.cn/sjbz/?lx=dongman&amp;format=images&amp;method=mobile&quot;)body.ready:before opacity: 1// Nav bar fixes.navbar background-color: rgba(255,255,255,0.8) backdrop-filter: blur(10px) -webkit-backdrop-filter: blur(10px).navbar-main .navbar-menu background-color: transparent .navbar-item &amp;.is-active color: #3273dc font-weight: bold &amp;:hover color: #3273dc background-color: primary-color @media screen and (min-width: screen-desktop) .navbar-menu .navbar-start margin-left: 2em @media screen and (max-width: screen-tablet - 1) .navbar-menu flex-direction: column .navbar-start .navbar-end justify-content: center overflow-x: auto .navbar-item padding: .5rem .navbar-end padding-bottom: .5rem// Card fixes.card overflow: visible transition: background-color 0.5s ease background-color: rgba(255,255,255,0.95) &amp;:hover background-color: rgba(255,255,255,1) &amp;.card-transparent background-color: transparent !important .level-start, .level-end overflow: hidden@media screen and (min-width: screen-tablet) .column-main, .column-left, .column-right, .column-right-shadow &amp;.is-sticky top: 10px// Article horizontal scroll bar.article .content overflow: auto// Footer fixesfooter.footer background-color: transparent.footer backdrop-filter: blur(10px) -webkit-backdrop-filter: blur(10px) position: relative &amp;:before content: '' position: absolute top: 0 left: 0 width: 100% height: 100% background-color: rgba(255,255,255,0.8).footer-logo img max-height: 2rem.footer a:not(.button) color: inherit &amp;:hover text-decoration: underline// Section fixes.section .container .columns -webkit-justify-content: center justify-content: center// Selection::selection color: white background-color: primary-color-light::-moz-selection color: white background-color: primary-color-light// Colorsa color: link-color.button.is-link background-color: primary-colorarticle.article .article-meta overflow-y: hidden .title width: fit-content img max-height: 800pxarticle .title a background-image: linear-gradient(transparent calc(100% - 1px), primary-color 1px) background-repeat: no-repeat background-size: 0 100% transition: all .25s ease-in-out .title:hover a // override another !important color: primary-color !important background-size: 100% 100%.button.is-link:hover, .button.is-link.is-hovered background-color: primary-color-hover.button.is-link:active, .button.is-link.is-active background-color: primary-color-active.pagination-link.is-current background-color: primary-color border-color: primary-color-active// Fix fontawsome icon 不等宽.navbar-main .navbar-menu .navbar-end .navbar-item min-width 35px justify-content: center -webkit-justify-content: center// 版权声明.article-licensing z-index: 0#busuanzi_container_page_pv display: none !important.card .v .vlist .vcard .vcontent text-align: inherit.searchbox .searchbox-pinyin display: flex align-items: center user-select: none input vertical-align: middle span position: relative top: 1px.button.link-more margin-top 0.75rem.post-navigation .level-item flex-shrink: 1.twikoo-new-content display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;// animals.symbolic-animals color: #3273dc icarus/source/style.styl #在该文件最后添加icarus/source/style.styl >folded1@import &quot;plus&quot; 2023/7/9尝试实现toc的侧边栏显示功能toc侧边栏显示功能在文章头部加入toc: true 尝试实现文章页面两栏放大文章页面放大两栏icarus中可能没有_config.post.yml，需要自己新建文件夹。icarus 5.0.0版本后，配置文件通常放在主题文件外面需要注意。 设置文章页面为双栏目在Blog文件下，新建**_config.post.yml**。把需要的widget显示到一边，可以参考官方文档Icarus用户指南 - 主题配置 - Icarus (ppoffice.github.io) 修改icarus主题下layout文档（Icarus/layout/layout.jsx）注意： 减号(-)：删除这一行 加号(+)：添加这一行 Icarus/layout/layout.jsx >folded1234 &lt;Head site={site} config={config} helper={helper} page={page} /&gt;- &lt;body class={`is-${columnCount}-column`}&gt;+ &lt;body class={`is-3-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; Icarus/layout/layout.jsx >folded1234 'is-12': columnCount === 1,- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3 修改widgets.jsx (layout/common/widgets.jsx)layout/common/widgets.jsx >folded12345678 function getColumnSizeClass(columnCount) { switch (columnCount) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3: return 'is-4-tablet is-4-desktop is-3-widescreen'; } 优化不同屏幕下的宽度(include/style/responsive.styl)include/style/responsive.styl >folded1234567891011121314151617 +widescreen()+ .is-3-column .container+ max-width: $widescreen - $gap+ width: $widescreen - $gap+ .is-1-column .container, .is-2-column .container max-width: $desktop - 2 * $gap width: $desktop - 2 * $gap +fullhd()+ .is-3-column .container+ max-width: $fullhd - 2 * $gap+ width: $fullhd - 2 * $gap+ .is-2-column .container max-width: $widescreen - 2 * $gap width: $widescreen - 2 * $gap 参考文献：[1] https://www.alphalxy.com/2019/03/customize-icarus/ [2] Icarus用户指南 - 主题配置 - Icarus (ppoffice.github.io) //此后的博客主题完善过程，将以日期分为多个文章记录","link":"/posts/c4442e98/"},{"title":"博客更新日志（2）","text":"实现左侧栏滑动的同时，目录黏附顶端原来只支持侧边栏整体粘性定位，为了阅读体验，只针对目录开启粘性定位，增加 column-left is-sticky 类，并调整样式。 source/js/main.js >folded123 if ($toc.length &gt; 0) {+ $toc.addClass('column-left is-sticky'); const $mask = $('&lt;div&gt;'); include/style/widget.styl >folded123+#toc+ max-height: calc(100vh - 22px)+ overflow-y: scroll 参考文献：[1] https://www.alphalxy.com/2019/03/customize-icarus/","link":"/posts/154f879f/"},{"title":"二分查找","text":"第一题题目描述给定一个按照升序排列的长度为 n的整数数组，以及 q个查询。 对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 00 开始计数）。 如果数组中不存在该元素，则返回 -1 -1。 输入格式第一行包含整数 n 和 q，表示数组长度和询问个数。 第二行包含 n个整数（均在 1∼10000 范围内），表示完整数组。 接下来 q 行，每行包含一个整数 k，表示一个询问元素。 输出格式共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。 如果数组中不存在该元素，则返回 -1 -1。 数据范围1≤n≤1000001≤q≤100001≤k≤10000 输入样例：123456 31 2 2 3 3 4345 输出样例：1233 45 5-1 -1 代码描述1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;const int N=1e6+10;int a[N];int main(){ int n,q,k; scanf(&quot;%d%d&quot;,&amp;n,&amp;q); for(int i=0;i&lt;n;i++) { scanf(&quot;%d&quot;,&amp;a[i]); } for(int i=0;i&lt;q;i++) { scanf(&quot;%d&quot;,&amp;k); int l=0,r=n-1; //第一个a[l]=k，查找最左边的位置 while(l&lt;r) { int mid=l+r&gt;&gt;1; if(a[mid]&gt;=k) r=mid; else l=mid+1; } //如果该值，不是 if(a[l]!=k) cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl; else //查找最后一个k（最右边的位置）， { cout&lt;&lt;l&lt;&lt;&quot; &quot;; l=0,r=n-1; while(l&lt;r) { int mid=1+r+1&gt;&gt;1; if(a[mid]&lt;=k) l=mid; else r=mid-1; } cout&lt;&lt;l&lt;&lt;endl; } } return 0;} 思路解析用二分去查找元素，要求数组的有序性或者拥有类似于有序的性质。所以写之前，就要考虑好想要查找的是什么。 就本题而言，一个包含重复元素的有序序列，要求输出某元素出现的起始位置和终止位置。所以，需要写两个二分，一个需要找到 &gt;= x 的第一个数，另一个需要找到 &lt;= x 的最后一个数。 二分查找的两套模板（如下图所示）： 1234567891011121314151617181920212223242526bool check(int x) {/* ... */} // 检查x是否满足某种性质// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：//找的是左边界int bsearch_1(int l, int r){ while (l &lt; r) { int mid = l + r &gt;&gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质，q[mid]&gt;=x else l = mid + 1; } return l;}// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：//即找的是右边界int bsearch_2(int l, int r){ while (l &lt; r) { int mid = l + r + 1 &gt;&gt; 1; //+1是为了防止死循环，如[1,1]区间，true时 if (check(mid)) l = mid; //q[mid]&lt;=x else r = mid - 1; } return l;} 第一套，查找的是左边界；第二套，查找的是右边界。","link":"/posts/e8eb0481/"},{"title":"多元函数可微、可导、连续、一阶偏导数连续关系","text":"​ 多元函数与一元函数的性质存在许多差异，笔者也存在许多困惑。因此，记录下自己的学习过程和所思所想。 一阶偏导连续与可导的关系","link":"/posts/8df30b8f/"},{"title":"Spawn_failed处理报告","text":"一、错误说明在上传Hexo博客到搭建到 Github 的项目时，已经使用 hexo s 预览成功了，但在 hexo d 部署到个人博客的时候出现了以下问题：![](Spawn-failed处理报告/hexo d部署失败.png)这种情况说明，Github公钥出现错误，重新添加公钥即可。 1234567公钥：使用https协议，每次pull, push都要输入密码，相当的烦。 使用git协议，然后使用ssh密钥。这样可以省去每次都输密码。公钥我们一般是给服务器的,他们到时候在权限中加入我给的公钥,然后当我从远地仓库中下载项目的时候,我在 git clone xxx 的时候，那个服务器我通过他的绑定的公钥来匹配我的私钥，这个时候,如果匹配,则就可以正常下载,如果不匹配,则失败。大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。 二、修改配置按照提示，先查看自己的博客配置文件 _config.yml ，在文件最底处修改内容如下： 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git # yourname，自己Github用户名 branch: master # 设置分支管理 三、添加公钥3.1 测试链接在博客目录，打开 Git Bash Here 输入以下代码 1ssh -T git@github.com 如下图结果，Permission denied(publickey) ，证明确实缺少公钥。![](Spawn-failed处理报告/Permission denied(publickey).png) 3.2 添加公钥首先在本地创建 SSH Keys 1ssh-keygen -t rsa -C \"yourmail\" # 后面为Github注册邮箱 注意在 Overwrite(y/n)? 后添加 y 后回车，其它一直回车，生成 SSH Keys根据上图找到路径 xxx/.ssh/id_rsa.pub ，打开文件，复制全部文本进入自己的Github，找到SSH/Add new，输入SSH Keys，将复制来的内容粘贴在 Key 中。保存！![](Spawn-failed处理报告/Pasted image 20240117185033.png)![](Spawn-failed处理报告/Pasted image 20240117185040.png) 3.3 重新部署先测试SSH连接 : 1ssh -T git@github.com ![](Spawn-failed处理报告/Pasted image 20240117185434.png)成功连接！重新部署项目hexo d![](Spawn-failed处理报告/Pasted image 20240117185539.png)部署成功！(如果还是无效的话，见四) 四、ssh超时错误笔者在添加公钥的同时，设置了.ssh配置文件config中的 Port 。 1234567891011121314151617181920212223242526272829303132$ git clone git@github.com:xxxxx/xxxx.git my-awesome-projCloning into 'my-awesome-proj'...ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository.$ # This should also timeout$ ssh -T git@github.comssh: connect to host github.com port 22: Connection timed out$ # but this might work$ ssh -T -p 443 git@ssh.github.comHi xxxx! You've successfully authenticated, but GitHub does not provide shell access.$ # Override SSH settings$ vim ~/.ssh/config //没有该文件，就新建一个```# Add section below to itHost github.com Hostname ssh.github.com Port 443```$ ssh -T git@github.comHi xxxxx! You've successfully authenticated, but GitHub does not provide shell access.$ git clone git@github.com:xxxxxx/xxxxx.git my-awesome-projCloning into 'my-awesome-proj'...remote: Enumerating objects: 15, done.remote: Counting objects: 100% (15/15), done.remote: Compressing objects: 100% (14/14), done.remote: Total 15 (delta 0), reused 15 (delta 0), pack-reused 0Receiving objects: 100% (15/15), 22.90 KiB | 4.58 MiB/s, done.","link":"/posts/cc739906/"}],"tags":[{"name":"递归","slug":"递归","link":"/tags/%E9%80%92%E5%BD%92/"},{"name":"不带头结点","slug":"不带头结点","link":"/tags/%E4%B8%8D%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9/"},{"name":"按值删除","slug":"按值删除","link":"/tags/%E6%8C%89%E5%80%BC%E5%88%A0%E9%99%A4/"},{"name":"单链表","slug":"单链表","link":"/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"带头结点","slug":"带头结点","link":"/tags/%E5%B8%A6%E5%A4%B4%E7%BB%93%E7%82%B9/"},{"name":"最小值","slug":"最小值","link":"/tags/%E6%9C%80%E5%B0%8F%E5%80%BC/"},{"name":"高效算法","slug":"高效算法","link":"/tags/%E9%AB%98%E6%95%88%E7%AE%97%E6%B3%95/"},{"name":"元素递增","slug":"元素递增","link":"/tags/%E5%85%83%E7%B4%A0%E9%80%92%E5%A2%9E/"},{"name":"逆序","slug":"逆序","link":"/tags/%E9%80%86%E5%BA%8F/"},{"name":"共享栈","slug":"共享栈","link":"/tags/%E5%85%B1%E4%BA%AB%E6%A0%88/"},{"name":"栈","slug":"栈","link":"/tags/%E6%A0%88/"},{"name":"判断对称性","slug":"判断对称性","link":"/tags/%E5%88%A4%E6%96%AD%E5%AF%B9%E7%A7%B0%E6%80%A7/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"空间复杂度低","slug":"空间复杂度低","link":"/tags/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BD%8E/"},{"name":"icarus","slug":"icarus","link":"/tags/icarus/"},{"name":"日志","slug":"日志","link":"/tags/%E6%97%A5%E5%BF%97/"},{"name":"查找","slug":"查找","link":"/tags/%E6%9F%A5%E6%89%BE/"},{"name":"math","slug":"math","link":"/tags/math/"},{"name":"advanced mathematics","slug":"advanced-mathematics","link":"/tags/advanced-mathematics/"},{"name":"Spawn_failed","slug":"Spawn-failed","link":"/tags/Spawn-failed/"}],"categories":[{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"单链表","slug":"算法/单链表","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E9%93%BE%E8%A1%A8/"},{"name":"栈","slug":"算法/栈","link":"/categories/%E7%AE%97%E6%B3%95/%E6%A0%88/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"二分查找","slug":"算法/二分查找","link":"/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"math","slug":"math","link":"/categories/math/"},{"name":"栈","slug":"算法/单链表/栈","link":"/categories/%E7%AE%97%E6%B3%95/%E5%8D%95%E9%93%BE%E8%A1%A8/%E6%A0%88/"},{"name":"icarus","slug":"hexo/icarus","link":"/categories/hexo/icarus/"},{"name":"advanced mathematics","slug":"math/advanced-mathematics","link":"/categories/math/advanced-mathematics/"},{"name":"报错","slug":"hexo/报错","link":"/categories/hexo/%E6%8A%A5%E9%94%99/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"留言板","text":"留下足迹吧！","link":"/guestbook/index.html"},{"title":"About me","text":"这里是Nanachilil的旧仓库。目前主要用于个人在it领域的学习记录、icarus主题美化的过程记录。 由于个人语言表达能力的不足，文章多少有些不足之处。欢迎大家留言讨论。 兴趣爱好：健身、悬疑恐怖故事、推理小说 本站文章如无特别声明，均为原创，采用 知识共享署名 4.0 国际许可协议 进行许可，转载请注明来源。 本站采用了 Hexo 静态博客框架，主题为 Icarus。有使用上的疑问可在 Issue 中提问，也可在博客中留言。 本站使用 不蒜子 和 Google Analytics 统计访客数据，包括但不限于您的 IP 地址、地理位置、访问页面等，继续浏览代表您接受我们收集此类信息。如您不接受，可选择禁用本站 Javascript 权限（例：选择地址栏左边的小锁 - 站点权限 - Javascript - 阻止），这不会影响您正常浏览站内博客文章，但会影响搜索、评论等功能。","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}